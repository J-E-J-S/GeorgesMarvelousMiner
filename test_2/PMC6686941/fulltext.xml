<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?><?DTDIdentifier.IdentifierType public?><?SourceDTD.DTDName JATS-journalpublishing1.dtd?><?SourceDTD.Version 1.1?><?ConverterInfo.XSLTName jp2nlmx2.xsl?><?ConverterInfo.Version 1?><front><journal-meta><journal-id journal-id-type="nlm-ta">G3 (Bethesda)</journal-id><journal-id journal-id-type="iso-abbrev">Genetics</journal-id><journal-id journal-id-type="hwp">G3: Genes, Genomes, Genetics</journal-id><journal-id journal-id-type="pmc">G3: Genes, Genomes, Genetics</journal-id><journal-id journal-id-type="publisher-id">G3: Genes, Genomes, Genetics</journal-id><journal-title-group><journal-title>G3: Genes|Genomes|Genetics</journal-title></journal-title-group><issn pub-type="epub">2160-1836</issn><publisher><publisher-name>Genetics Society of America</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">6686941</article-id><article-id pub-id-type="publisher-id">GGG_400373</article-id><article-id pub-id-type="doi">10.1534/g3.119.400373</article-id><article-categories><subj-group subj-group-type="heading"><subject>Software and Data Resources</subject></subj-group></article-categories><title-group><article-title>isqg: A Binary Framework for <italic>in Silico</italic> Quantitative Genetics</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Toledo</surname><given-names>Fernando H.</given-names></name><xref ref-type="aff" rid="aff1">*</xref><xref ref-type="corresp" rid="cor1"><sup>1</sup></xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-3202-1784</contrib-id><name><surname>P&#x000e9;rez-Rodr&#x000ed;guez</surname><given-names>Paulino</given-names></name><xref ref-type="aff" rid="aff1">*</xref><xref ref-type="aff" rid="aff2"><sup>&#x02020;</sup></xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0001-9429-5855</contrib-id><name><surname>Crossa</surname><given-names>Jos&#x000e9;</given-names></name><xref ref-type="aff" rid="aff1">*</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-1468-4867</contrib-id><name><surname>Burgue&#x000f1;o</surname><given-names>Juan</given-names></name><xref ref-type="aff" rid="aff1">*</xref></contrib><aff id="aff1"><label>*</label>International Maize and Wheat Improvement Center (CIMMYT), Km 45 Carretera M&#x000e9;xico-Veracruz CP 56130, El Bat&#x000e1;n, Texcoco, Edo. de M&#x000e9;xico, M&#x000e9;xico and</aff><aff id="aff2"><label>&#x02020;</label>Colegio de Postgraduados CP 56230, Montecillos, Edo. de M&#x000e9;xico, M&#x000e9;xico</aff></contrib-group><author-notes><corresp id="cor1"><label>1</label>Corresponding author: International Maize and Wheat Improvement Center (CIMMYT), Km 45 Carretera M&#x000e9;xico-Veracruz CP 56130, El Bat&#x000e1;n, Texcoco, Edo. de M&#x000e9;xico, M&#x000e9;xico, E-mail: <email>f.toledo@cgiar.org</email></corresp></author-notes><pub-date pub-type="epub"><day>14</day><month>6</month><year>2019</year></pub-date><pub-date pub-type="collection"><month>8</month><year>2019</year></pub-date><volume>9</volume><issue>8</issue><fpage>2425</fpage><lpage>2428</lpage><history><date date-type="received"><day>02</day><month>4</month><year>2019</year></date><date date-type="accepted"><day>11</day><month>6</month><year>2019</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2019 Toledo <italic>et al.</italic></copyright-statement><copyright-year>2019</copyright-year><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><self-uri xlink:title="pdf" xlink:href="2425.pdf"/><abstract><p>The <sc>dna</sc> is the fundamental basis of genetic information, just as bits are for computers. Whenever computers are used to represent genetic data, the computational encoding must be efficient to allow the representation of processes driving the inheritance and variability. This is especially important across simulations in view of the increasing complexity and dimensions brought by genomics. This paper introduces a new binary representation of genetic information. Algorithms as bitwise operations that mimic the inheritance of a wide range of polymorphisms are also presented. Different kinds and mixtures of polymorphisms are discussed and exemplified. Proposed algorithms and data structures were implemented in C++ programming language and is available to end users in the R package &#x0201c;isqg&#x0201d; which is available at the R repository (<sc>cran</sc>). Supplementary data are available online.</p></abstract><kwd-group><kwd>Algorithms</kwd><kwd>Computational</kwd><kwd>Biology</kwd><kwd>Recombination</kwd><kwd>Simulation</kwd></kwd-group><counts><fig-count count="1"/><table-count count="0"/><equation-count count="1"/><ref-count count="14"/><page-count count="4"/></counts></article-meta></front><body><p>The complexity and organization based on <sc>dna</sc> structure were evolutionarily optimized to faithfully store and transfer biological information (<xref rid="bib4" ref-type="bibr">Bancroft <italic>et al.</italic> 2001</xref>). This complexity requires a proper computational representation in order to increase storage capacity, reduce the memory footprint and the run time of analyses. The fundamental unit for computer data are the binary digit (bit), just as the nucleotides are for <sc>dna</sc>. In this regard, each nucleotide may be represented as binary droplets <italic>i.e.</italic>, mapping {<sc>a</sc>, <sc>c</sc>, <sc>g</sc>, <sc>t</sc>} to <inline-formula><mml:math id="me1"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>00</mml:mn><mml:mo>,</mml:mo><mml:mn>01</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>11</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, respectively. Thus, the bitset 01101100 matches to the <sc>dna</sc> sequence <sc>cgta</sc>.</p><p>This analogy allows straightforward <italic>in silico</italic> representation of genetic polymorphisms by bits. On the other hand, a series of experiments have proved the value of synthetic <sc>dna</sc> as an alternative for storage. However, any <sc>dna</sc>-based storage system must own the capacity to retrieve the properties of the stored information (<xref rid="bib7" ref-type="bibr">Erlich and Zielinski 2017</xref>). Computational representation of genetic data must also cater to depict the processes that drive the inheritance and genetic variability. This is especially important whenever computers are used for simulations.</p><p>Simulations are invaluable to the genetic research, in which computer programs are used to abstract complex models and the replications of pseudo data incorporate an inherent stochasticity common to genetic mechanisms (<xref rid="bib9" ref-type="bibr">Hoban <italic>et al.</italic> 2012</xref>). Even when numeric or analytical approaches cannot be accessed, the simulations can be employed for inference, prediction and evaluation of new methods (<xref rid="bib13" ref-type="bibr">Peng <italic>et al.</italic> 2015</xref>). To do so, an efficient abstraction of computational representation of the genetic variability is required.</p><p>Genetic information at sequence-level from various platforms is usually compressed by methods that are strongly linked to binary representation (<xref rid="bib12" ref-type="bibr">Li <italic>et al.</italic> 2009</xref>). Methods for compressing genomic data into binary encoding are already being used by high-performance applications (<xref rid="bib2" ref-type="bibr">Abecasis <italic>et al.</italic> 2002</xref>; <xref rid="bib14" ref-type="bibr">Purcell <italic>et al.</italic> 2007</xref>). These representations, however, were designed with analytical purposes without taking account the <sc>dna</sc> structure, <italic>i.e.</italic>, the linkage phase between strands. It must be noted that simulations of meiosis, mutation and more recently, gene editing, are dependent on the strand base structure of the <sc>dna</sc>.</p><p>This paper introduces a new binary encoding of genome-level data that preserves the strand-based structure. Generalizations are provided to support a wide range of known polymorphisms. The algorithms to simulate the generation of variability are presented in terms of bitwise operations. The algorithms and data structures are available to users as an R package &#x0201c;isqg&#x0201d; which is available at the official R repository (<sc>cran</sc>).</p><sec sec-type="methods" id="s1"><title>Methods</title><p>An oligonucleotide is a linear sequence of loci (<italic>l</italic>), each one indexed by a genome position (<italic>x</italic>), which may be associated with a physical or map coordinates. Thus, a binary representation of a <sc>dna</sc> strands consists of a set of bits (<inline-formula><mml:math id="me2"><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) assigned to genome positions (<inline-formula><mml:math id="me3"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>). Each bit has only two states, while a collection of <italic>n</italic> bits expands to <inline-formula><mml:math id="me4"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> states. In this sense, a locus represented by a single bit is biallelic and may be seen as single-nucleotide polymorphisms. Therefore, a collection of bits associated with the same position may represent different kinds of polymorphisms.</p><p>Homologous recombination over diploids is a universal mechanism in which sister chromatids pair with each other and undergo exchange of their contents. Considering two binary sets (<italic>&#x003b1;</italic> and <italic>&#x003b2;</italic>) as both <sc>dna</sc> strands, the mosaic recombination (<italic>&#x003b4;</italic>) can be obtained by bitwise operations. To do this, another set (<italic>&#x003b3;</italic>) must be introduced, which works as a bit mask. This mask controls the flow of the content between both chromatids. It works as a logical conditional statement such as an if-else block and thus, allow the composition of the mosaic between both chromatids <italic>i.e.</italic>, an 1 entry in <italic>&#x003b3;</italic> means the bit is taken from <italic>&#x003b1;</italic>, while a 0 implies it is taken from <italic>&#x003b2;</italic>. As <italic>&#x003b1;</italic>, <italic>&#x003b2;</italic>, <italic>&#x003b4;</italic> and <italic>&#x003b3;</italic> are binary sets, a single bitwise statement must be performed combining the operators <sc>and</sc> (&#x00026;), <sc>or</sc> (<inline-formula><mml:math id="me5"><mml:mo>|</mml:mo></mml:math></inline-formula>) and <sc>not</sc> (<inline-formula><mml:math id="me6"><mml:mo>&#x0223c;</mml:mo></mml:math></inline-formula>), that is:<disp-formula id="eq1"><mml:math id="me7"><mml:mrow><mml:mi mathvariant="italic">&#x003b4;</mml:mi><mml:mo>&#x02190;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="italic">&#x003b3;</mml:mi><mml:mo>&#x00026;</mml:mo><mml:mi mathvariant="italic">&#x003b1;</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>&#x0223c;</mml:mo><mml:mi mathvariant="italic">&#x003b3;</mml:mi><mml:mo>&#x00026;</mml:mo><mml:mi>&#x003b2;</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math><label>(1)</label></disp-formula>In the simplest case, with <italic>k</italic> biallelic loci, all <inline-formula><mml:math id="me8"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> masks are equally probable, <italic>i.e.</italic>, the content in <italic>&#x003b4;</italic> is independently chosen between <italic>&#x003b1;</italic> and <italic>&#x003b2;</italic> with equal probabilities. To contemplate the linkage between loci close to each other, restrictions on the probabilities of the masks, conditionally on the coordinates, must be assigned <italic>e.g.</italic>, through recombination models (<xref rid="bib5" ref-type="bibr">Copennhaver <italic>et al.</italic> 2002</xref>, see references therein). Regardless the recombination model, given the positions where the events occur, binary operations allow building the corresponding mask. For each event, the locus with the smaller position, greater than or equal to the chiasma position, is found (upper bound). The index of this locus is used to right shift (<inline-formula><mml:math id="me9"><mml:mo>&#x0226b;</mml:mo></mml:math></inline-formula>) a replete binary set, resulting in the bit mask for that event. A recursive chain of exclusive or (<sc>xor</sc>/<inline-formula><mml:math id="me10"><mml:mo>&#x02227;</mml:mo></mml:math></inline-formula>) assignments over those masks build the mask merging all events:</p><p><bold>Algorithm 1</bold>: Build bit masks for homologous recombination</p><p>1: <bold>procedure</bold> R<sc>ecombination</sc>M<sc>ask</sc>(<italic>chiasmata</italic>, <italic>map</italic>)</p><p>2: <italic>mask</italic>
<inline-formula><mml:math id="me11"><mml:mrow><mml:mo>&#x02190;</mml:mo><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> ;</p><p>3: <bold>if</bold>
<inline-formula><mml:math id="me12"><mml:mrow><mml:mi mathvariant="bold">size</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula><bold> then</bold></p><p>4: <inline-formula><mml:math id="me13"><mml:mrow><mml:mi>b</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>k</mml:mi><mml:mi>s</mml:mi><mml:mo>&#x02190;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> ;</p><p>5: <bold>for</bold>
<italic>chiasma</italic>
<bold>in</bold>
<italic>chiasmata</italic>
<bold>do</bold></p><p>6: <inline-formula><mml:math id="me14"><mml:mrow><mml:mi>b</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>k</mml:mi><mml:mi>s</mml:mi><mml:mo>&#x02190;</mml:mo><mml:mi mathvariant="bold">upperBound</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mtext>&#x02009;</mml:mtext><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mstyle><mml:mtext>&#x02009;</mml:mtext><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> ;</p><p>7: <inline-formula><mml:math id="me15"><mml:mrow><mml:mi>e</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mo>&#x02190;</mml:mo><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>&#x0226b;</mml:mo><mml:mi>b</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>k</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> ;</p><p>8: <inline-formula><mml:math id="me16"><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>k</mml:mi><mml:mo>&#x02190;</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>k</mml:mi><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02227;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mi>e</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> ;</p><p>9: <bold>if</bold>
<inline-formula><mml:math id="me17"><mml:mrow><mml:mi mathvariant="bold">getRandom</mml:mi><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow/><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo>&#x0003e;</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:math></inline-formula><bold> then</bold></p><p>10: <inline-formula><mml:math id="me18"><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>k</mml:mi><mml:mo>&#x02190;</mml:mo><mml:mtext>&#x02009;</mml:mtext><mml:mo>&#x0223c;</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> ;</p><p>11: <inline-formula><mml:math id="me19"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>n</mml:mi></mml:mstyle><mml:mtext>&#x02009;</mml:mtext><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> ;</p><p>The independent assortment of chromosomes also contributes to the generation of variability. <xref ref-type="disp-formula" rid="eq1">Equation 1</xref> considers all loci belonging to the same linkage group. Therefore, when performing the segregation in each chromosome, the independence among them is ensured through a random process that flips the mask (<italic>&#x003b3;</italic>) beforehand, <italic>i.e.</italic>, ones turn zeros and vice-versa, which is carried out by the <sc>not</sc> operator (<inline-formula><mml:math id="me20"><mml:mo>&#x0223c;</mml:mo></mml:math></inline-formula>) (Lines 9-10 of Algorithm 1).</p><p>The construction of bit masks is independent of any genetic content, using only the positions of the loci and chiasmata as inputs. This feature allows the individual to be stored only by its <sc>dna</sc> strands. As gametes are requested, the masks are retrieved from the generator, common to all individuals. In this sense, any recombination models can be employed, and users are able to define their own model to support <italic>e.g.</italic>, recombination hotspots (<xref ref-type="fig" rid="fig1">Figure 1</xref>).</p><fig id="fig1" fig-type="figure" orientation="portrait" position="float"><label>Figure 1</label><caption><p>Schematic representation of the classes&#x02019; hierarchy implemented in &#x0201c;isqg&#x0201d;.</p></caption><graphic xlink:href="2425f1"/></fig><p>Species are often defined as a group of organisms in which any pair of individuals can produce fertile offspring. It can also define specie by identifying common <sc>dna</sc> features such as the karyotype. In this sense, it is defined as &#x0201c;specie&#x0201d; the generator class of objects which holds the needed information to link different individuals that share the characteristics at the <sc>dna</sc> level and can produce fertile offspring (<xref ref-type="fig" rid="fig1">Figure 1</xref>). The name given for this abstraction adhere to the biological definition and makes a straightforward relation between real and <italic>in silico</italic> information.</p><p>In addition, as recombination depends only to the loci&#x02019;s positions, the linkage among a collection of bits assigned to the same position will never break, working as a single loci. This framework also supports a mixture of different types of polymorphism coexisting together, such as the one at the sequence-level or those with multiple alleles, which may unveil other understanding about the association of <sc>snp</sc>s (biallelics) with complex quantitative traits driven by multi-allelic factors.</p><p>Mutations and/or gene editing changing the state of locus <italic>i</italic> from parent to offspring can also be performed by binary operations. Given the index of the loci to be changed (edited or mutated), a right shift on an empty bitset results in a bit mask for this event. Then, an exclusive or (<sc>xor</sc>/<inline-formula><mml:math id="me21"><mml:mo>&#x02227;</mml:mo></mml:math></inline-formula>) operation between the mask and a DNA strand will toggle the bits where the event occurs. This procedure can be implemented analogously to Algorithm 1.</p><sec sec-type="data-availability" id="s2"><title>Data Availability</title><p>Software are released under a public license (<sc>gpl</sc>-2); source codes and binary version of the software are available at the official public repository of R packages (<sc>cran</sc>): <ext-link ext-link-type="uri" xlink:href="https://cran.r-project.org/package=isqg">https://cran.r-project.org/package=isqg</ext-link>. The authors affirm that all data necessary for confirming the conclusions of the article are present within the article, figures, and tables. Supplemental material available at FigShare: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.25387/g3.8162051">https://doi.org/10.25387/g3.8162051</ext-link>.</p></sec></sec><sec sec-type="results" id="s3"><title>Results</title><p>A detailed description of &#x0201c;isqg&#x0201d; can be found in its documentation. Below we present two case studies to highlight the &#x0201c;isqg&#x0201d; features. First, it is presented how users can define their own recombination process to be used over simulations. After, a more realistic quantitative genetic simulation is performed.</p><sec id="s4"><title>Custom Recombination</title><p>Example 1 show a situation where after the package is loaded, the example data (ToyMap) is loaded and an specie is started. Then, two completely contrasting individuals are initialized and the <inline-formula><mml:math id="me22"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="me23"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> as well as recombinant inbred lines (double-haploids) are generated from the <inline-formula><mml:math id="me24"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Genotypic data from the simulated individuals are then retrieved as numeric or keeping the phase information.</p><p><bold>Example 1:</bold> Simple simulation of crosses and double-haploids with &#x0201c;isqg&#x0201d;</p><p>&#x0003e; <monospace>library(isqg)</monospace></p><p>&#x0003e; <monospace>data(ToyMap)</monospace></p><p>&#x0003e; <italic>## start specie given the map</italic></p><p>&#x0003e; <monospace>spp &#x0003c;- set_specie(ToyMap)</monospace></p><p>&#x0003e; <italic>## start some &#x0201d;founders&#x0201d; individuals from specie</italic></p><p>&#x0003e; <monospace>AA &#x0003c;- spp$founder(code = &#x0201d;AA&#x0201d;)</monospace></p><p>&#x0003e; <monospace>aa &#x0003c;- spp$founder(code = &#x0201d;aa&#x0201d;)</monospace></p><p>&#x0003e; <italic>## making some crosses (cross</italic>, <italic>selfcross and dh)</italic></p><p>&#x0003e; <italic>## are accessible by standalone function and R6 methods</italic></p><p>&#x0003e; <monospace>F1 &#x0003c;-cross(n = 1, AA, aa) # the hybrid</monospace></p><p>&#x0003e; <monospace>F2 &#x0003c;- F1$selfcross(n = 1E3) # segregating population</monospace></p><p>&#x0003e; <monospace>RILs &#x0003c;- F1$dh(n = 1E3) # inbreeds</monospace></p><p>&#x0003e; <italic>## retrieving the genotypic data</italic></p><p>&#x0003e; <monospace>M &#x0003c;- genotype(RILs) # as numeric</monospace></p><p>&#x0003e; <monospace>N &#x0003c;- F1$genotype(phase = TRUE) # as character (phased)</monospace></p><p>By default, instances of the species are started giving as input the map with the genomic positions in Morgans (<italic>M</italic>) and the meiosis recombination is performed through a count location process (<xref rid="bib11" ref-type="bibr">Karlin and Liberman 1978</xref>). However, other recombination models can be employed thus, users can extend &#x0201c;isqg&#x0201d; capabilities. To do so, when initializing species as in Example 1, a function implementing the recombination process must be provided. As an example the authors share as a supplemental material a couple of commented C++ implementations for recombination processes in which markers segregate independently regardless of their position in the map as well as where recombinations happen in hotspots.</p><p>Having the extension code as a file <italic>e.g.</italic>, &#x0201c;Independent.cpp&#x0201d;, it can be seamlessly compiled and linked to R through the Rcpp package (<xref rid="bib6" ref-type="bibr">Eddelbuettel and Fran&#x000e7;ois 2011</xref>). Thus, users can simulated data according to any recombination model. Example 2 shows how users can check the behavior of the custom independent segregation in comparison with the standard count location process.</p><p><bold>Example 2:</bold> Including and using extension for custom user-defined recombination process</p><p>&#x0003e; <monospace>library(isqg)</monospace></p><p>&#x0003e; <monospace>data(ToyMap)</monospace></p><p>&#x0003e; <italic>## standard specie as in Example 1</italic></p><p>&#x0003e; <monospace>standard &#x0003c;- set_specie(ToyMap)</monospace></p><p>&#x0003e; <italic>## sample 100 gametes from standard process</italic></p><p>&#x0003e; <monospace>standard$gamete(100)</monospace></p><p>&#x0003e; <italic>## require Rcpp package</italic></p><p>&#x0003e; <monospace>library(Rcpp)</monospace></p><p>&#x0003e; <italic>## compile and link Example 2 at file Independent.cpp</italic></p><p>&#x0003e; <monospace>sourceCpp(file = &#x0201d;Independent.cpp&#x0201d;, rebuild = TRUE)</monospace></p><p>&#x0003e; <italic>## specie with custom recombination</italic></p><p>&#x0003e; <monospace>custom &#x0003c;- set_specie(ToyMap, meiosis = indepp())</monospace></p><p>&#x0003e; <italic>## sample 100 gametes from custom process</italic></p><p>&#x0003e; <monospace>custom$gamete(100)</monospace></p></sec><sec id="s5"><title>Quantitative Genetics Simulation</title><p>Considering a breeding scenario where <inline-formula><mml:math id="me25"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mo>:</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> progenies are generated from two contrasting parents. One question that may arise is how different are the predictions of the breeding values when it is used the realized genomic kinship (matrix <inline-formula><mml:math id="me26"><mml:mi mathvariant="bold-italic">G</mml:mi></mml:math></inline-formula>), taking account the Mendelian samplig, or the resemblance between individuals (matrix <inline-formula><mml:math id="me27"><mml:mi mathvariant="bold-italic">A</mml:mi></mml:math></inline-formula>) <italic>i.e.</italic>, the coefficient of identity by descent. To do so, a specie is initialized with a genetic map having fives chromosomes each one with 1000 equally spaced biallelic loci and a quantitative trait is defined with zero mean and additive effect of one for all loci. From this settings, two contrasting individuals and the <inline-formula><mml:math id="me28"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> are also initialized (Example 3).</p><p><bold>Example 3:</bold> Initializing structures and data for a simulation with &#x0201c;isqg&#x0201d;</p><p>&#x0003e; <italic>## generating map: 5 chromosomes and 1000 &#x0201d;genes&#x0201d; per chromosome</italic></p><p>&#x0003e; <monospace>map &#x0003c;- expand.grid(chr = 1:5, pos = seq(0, 2, length.out = 1000))</monospace></p><p>&#x0003e; <monospace>map$snp &#x0003c;- paste0(&#x0201d;s&#x0201d;, 1:(5 * 1000))</monospace></p><p>&#x0003e; <italic>## initializing &#x0201d;specie&#x0201d; and &#x0201d;infinitesimal&#x0201d; quantitative trait</italic></p><p>&#x0003e; <monospace>spp &#x0003c;- set_specie(map)</monospace></p><p>&#x0003e; <monospace>trait &#x0003c;- set_infty(spp, m = 0, a = 1, d = 0)</monospace></p><p>&#x0003e; <italic>## initializing two contrasting parents and the F1</italic></p><p>&#x0003e; <monospace>P1 &#x0003c;- spp$founder(code = &#x0201d;AA&#x0201d;)</monospace></p><p>&#x0003e; <monospace>P2 &#x0003c;- P$mirror()</monospace></p><p>&#x0003e; <monospace>F1 &#x0003c;- cross(n = 1, P1, P2)</monospace></p><p>After that, one may define an R function to simulated the above mentioned breeding scenario:</p><list list-type="roman-lower" id="L1"><list-item><p>generating inbreeding generations <italic>i.e.</italic>, <inline-formula><mml:math id="me29"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> population with <italic>N</italic> individuals as well as <inline-formula><mml:math id="me30"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mo>:</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> progenies with <italic>P</italic> individuals each;</p></list-item><list-item><p>getting the true breeding values regarding the defined quantitative trait and simulating phenotypes adding random deviates accoring to the a desired heritability (<inline-formula><mml:math id="me31"><mml:mrow><mml:msup><mml:mi>h</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>);</p></list-item><list-item><p>genotyping the individuals and obtaining the realized kinship matrix;</p></list-item><list-item><p>fitting the mixed models with both kinds of information (realized kinship and identity by descent); and</p></list-item><list-item><p>collecting and delivering the estimated additive and residual variances.</p></list-item></list><p>Replications of the simulated scenario are then obtained in which the collected statistics can be further analyzed (Example 4). Consider to load the package rrBLUP beforehand as its functions are used over the simulation (<xref rid="bib8" ref-type="bibr">Endelman 2011</xref>).</p><p><bold>Example 4:</bold> Defining and simulating breeding schemes with &#x0201c;isqg&#x0201d;</p><p>&#x0003e; <monospace>simulation &#x0003c;- function(zzz) {</monospace></p><p>+ <italic>## (i) inbreeding generations:</italic></p><p>+ <monospace>F2 &#x0003c;- F1$selfcross(n = N)</monospace></p><p>+ <monospace>F2_3 &#x0003c;- unlist(lapply(F2, function(x) x$selfcross(n = P)),</monospace></p><p>+ <monospace><italic>recursive = TRUE)</italic></monospace></p><p>+ <italic>## (ii) true breeding values **standardized** and phenotypes:</italic></p><p>+ <monospace>alphas &#x0003c;- scale(sapply(F2_3, function(x) x$alpha(trait)))</monospace></p><p>+ <monospace>phens &#x0003c;- rnorm(n = N * P, mean = alphas, sd = sqrt((1 - h2) / h2))</monospace></p><p>+ <italic>## (iii) VanRaden realized relationship matrix:</italic></p><p>+ <monospace>G &#x0003c;- A.mat(t(genotype(F2_3)))</monospace></p><p>+ <italic>## (iv) fitting the mixed models with A and G:</italic></p><p>+ <monospace>X &#x0003c;- rep(1, N * P)</monospace></p><p>+ <monospace>Z &#x0003c;- diag(N * P)</monospace></p><p>+ <monospace>mP &#x0003c;- mixed.solve(y = phens, X = X, Z = Z, K = A)</monospace></p><p>+ <monospace>mG &#x0003c;- mixed.solve(y = phens, X = X, Z = Z, K = G)</monospace></p><p>+ <italic>## (v) collecting and delivering statistics:</italic></p><p>+ <monospace>vgs &#x0003c;- c(vAP = mP$Vu, vAG = mG$Vu) <italic># additive variance</italic></monospace></p><p>+ <monospace>ves &#x0003c;- c(vEP = mP$Ve, vEG = mG$Ve) <italic># residuals variance</italic></monospace></p><p>+ <monospace>return(c(VG = vgs, Ve = ves))</monospace></p><p>+ <monospace>}</monospace></p><p>&#x0003e; <italic>## repeating 100 times the simulation</italic></p><p>&#x0003e; <monospace>output &#x0003c;- sapply(1:100, simulation)</monospace></p><p>This is a simple but realistic simulation that can be performed with &#x0201c;isqg&#x0201d;, trying to highlight how the simulation can be integrated with third part packages to analyze the simulated data such as rrBlup (<xref rid="bib8" ref-type="bibr">Endelman 2011</xref>). To reinforce the capabilities of the binary framework, we have found that with a population size of 100 and progeny size of 20 <italic>i.e.</italic>, 2000 simulated individuals, occupy less than one mega byte of memory and 100 replicates of the simulations using only one <sc>cpu</sc> in a standard laptop spent around 10 min which includes the times to fit the models.</p></sec></sec><sec sec-type="discussion" id="s6"><title>Discussion</title><p>Bitsets are implemented with a limit in size of <inline-formula><mml:math id="me32"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, which is the upper bound of unsigned long integer numbers in 64 bits architectures. Nevertheless, the variability found within the humans, crop and livestock species <italic>e.g.</italic>, wheat and bovine can be fully represented (<xref rid="bib3" ref-type="bibr">Bovine Genome Sequencing and Analysis Consortium 2009</xref>; <xref rid="bib1" ref-type="bibr">1000 Genomes Project Consortium <italic>et al.</italic> 2012</xref>; <xref rid="bib10" ref-type="bibr">International Wheat Genome Sequence Consortium 2018</xref>). Taking the largest chromosome of the human genome (248,956,422 BP) with two bits for each base to allow the four possible nucleotides, it is needed 497,912,844 bits which is smaller than the stated limit. In contrast to the representation of biallelic polymorphism by <sc>ascii</sc> characters (1 byte) or integer numbers (4 bytes) as found in alternative softwares, bits are at least 4 times smaller in modern computing. Moreover, bitwise operations act on chunks of 64 bits that are faster than loops over arrays.</p><p>The presented framework was implemented in C++ with an R interface. Access to bitsets is provided by the Boost library, and bit manipulations are carried out by functions in the standard template library. The package is available under a public license (<sc>gpl</sc>-2). Its low- and high-level interfaces provide great flexibility for users. A sample script showing a basic pipeline with other features is shared as a complementing material simulating a comparison of a few different recombination models.</p></sec></body><back><ack><title>Acknowledgments</title><p>Authors thank the support of <sc>cgiar</sc>&#x02019;s Excellence in Breeding Platform (<sc>e</sc>i<sc>b</sc>) funded by the Bill &#x00026; Melinda Gates Foundation and <sc>cgiar</sc>&#x02019;s research programs on Maize and Wheat (<sc>crp</sc>-Maize and <sc>crp</sc>-Wheat).</p></ack><fn-group><fn id="fn1"><p>Supplemental material available at FigShare: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.25387/g3.8162051">https://doi.org/10.25387/g3.8162051</ext-link>.</p></fn><fn id="fn2"><p>Communicating editor: D. J. de Koning</p></fn></fn-group><ref-list><title>Literature Cited</title><ref id="bib1"><mixed-citation publication-type="journal"><person-group person-group-type="author"><collab>1000 Genomes Project Consortium</collab><name name-style="western"><surname>Abecasis</surname><given-names>G. R.</given-names></name>, <name name-style="western"><surname>Auton</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Brooks</surname><given-names>L. D.</given-names></name>, <name name-style="western"><surname>DePristo</surname><given-names>M. A.</given-names></name><etal/></person-group>, <year>2012</year>&#x02003;<article-title>An integrated map of genetic variation from 1,092 human genomes</article-title>. <source>Nature</source>
<volume>491</volume>: <fpage>56</fpage>&#x02013;<lpage>65</lpage>. <pub-id pub-id-type="doi">10.1038/nature11632</pub-id><pub-id pub-id-type="pmid">23128226</pub-id></mixed-citation></ref><ref id="bib2"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Abecasis</surname><given-names>G. R.</given-names></name>, <name name-style="western"><surname>Cherny</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Cookson</surname><given-names>W.</given-names></name>, and <name name-style="western"><surname>Cardon</surname><given-names>L.</given-names></name></person-group>, <year>2002</year>&#x02003;<article-title>Merlin&#x02013;rapid analysis of dense genetic maps using sparse gene flow trees</article-title>. <source>Nat. Genet.</source>
<volume>30</volume>: <fpage>97</fpage>&#x02013;<lpage>101</lpage>. <pub-id pub-id-type="doi">10.1038/ng786</pub-id><pub-id pub-id-type="pmid">11731797</pub-id></mixed-citation></ref><ref id="bib3"><mixed-citation publication-type="journal"><person-group person-group-type="author"><collab>Bovine Genome Sequencing and Analysis Consortium</collab></person-group>, <year>2009</year>&#x02003;<article-title>The genome sequence of taurine cattle: a window to ruminant biology and evolution</article-title>. <source>Science</source>
<volume>324</volume>: <fpage>522</fpage>&#x02013;<lpage>528</lpage>. <pub-id pub-id-type="doi">10.1126/science.1169588</pub-id><pub-id pub-id-type="pmid">19390049</pub-id></mixed-citation></ref><ref id="bib4"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bancroft</surname><given-names>C.</given-names></name>, <name name-style="western"><surname>Bowler</surname><given-names>T.</given-names></name>, <name name-style="western"><surname>Bloom</surname><given-names>B.</given-names></name>, and <name name-style="western"><surname>Clelland</surname><given-names>C. T.</given-names></name></person-group>, <year>2001</year>&#x02003;<article-title>Long-term storage of information in dna</article-title>. <source>Science</source>
<volume>293</volume>: <fpage>1763</fpage>&#x02013;<lpage>1765</lpage>. <pub-id pub-id-type="doi">10.1126/science.293.5536.1763c</pub-id></mixed-citation></ref><ref id="bib5"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Copennhaver</surname><given-names>G. P.</given-names></name>, <name name-style="western"><surname>Housworth</surname><given-names>E. A.</given-names></name>, and <name name-style="western"><surname>Stahl</surname><given-names>F. W.</given-names></name></person-group>, <year>2002</year>&#x02003;<article-title>Crossover interference in arabidopsis</article-title>. <source>Genetics</source>
<volume>160</volume>: <fpage>1631</fpage>&#x02013;<lpage>1639</lpage>.<pub-id pub-id-type="pmid">11973316</pub-id></mixed-citation></ref><ref id="bib6"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Eddelbuettel</surname><given-names>D.</given-names></name>, and <name name-style="western"><surname>Fran&#x000e7;ois</surname><given-names>R.</given-names></name></person-group>, <year>2011</year>&#x02003;<article-title>Rcpp: Seamless R and C++ integration</article-title>. <source>J. Stat. Softw.</source>
<volume>40</volume>: <fpage>1</fpage>&#x02013;<lpage>18</lpage>. <pub-id pub-id-type="doi">10.18637/jss.v040.i08</pub-id></mixed-citation></ref><ref id="bib7"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Erlich</surname><given-names>Y.</given-names></name>, <name name-style="western"><surname>Zielinski</surname><given-names>D.</given-names></name></person-group>, <year>2017</year>&#x02003;<article-title>Dna fountain enables a robust and efficient storage architecture</article-title>. <source>Science</source>
<volume>355</volume>: <fpage>950</fpage>&#x02013;<lpage>954</lpage>. <pub-id pub-id-type="doi">10.1126/science.aaj2038</pub-id><pub-id pub-id-type="pmid">28254941</pub-id></mixed-citation></ref><ref id="bib8"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Endelman</surname><given-names>J. B.</given-names></name></person-group>, <year>2011</year>&#x02003;<article-title>Ridge regression and other kernels for genomic selection with r package rrblup</article-title>. <source>Plant Genome</source>
<volume>4</volume>: <fpage>250</fpage>&#x02013;<lpage>255</lpage>. <pub-id pub-id-type="doi">10.3835/plantgenome2011.08.0024</pub-id></mixed-citation></ref><ref id="bib9"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Hoban</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Bertorelle</surname><given-names>G.</given-names></name>, and <name name-style="western"><surname>Gaggiotti</surname><given-names>O. E.</given-names></name></person-group>, <year>2012</year>&#x02003;<article-title>Computer simulations: tools for population and evolutionary genetics</article-title>. <source>Natl. Rev.</source>
<volume>13</volume>: <fpage>110</fpage>&#x02013;<lpage>122</lpage>. <pub-id pub-id-type="doi">10.1038/nrg3130</pub-id></mixed-citation></ref><ref id="bib10"><mixed-citation publication-type="journal"><person-group person-group-type="author"><collab>International Wheat Genome Sequence Consortium</collab></person-group>, <year>2018</year>&#x02003;<article-title>Shifting the limits in wheat research and breeding using a fully annotated reference genome</article-title>. <source>Science</source>
<volume>361</volume>: <fpage>661</fpage>
<pub-id pub-id-type="doi">10.1126/science.aar7191</pub-id></mixed-citation></ref><ref id="bib11"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Karlin</surname><given-names>S.</given-names></name>, and <name name-style="western"><surname>Liberman</surname><given-names>U.</given-names></name></person-group>, <year>1978</year>&#x02003;<article-title>Classifications and comparisons of multilocus recombination distributions</article-title>. <source>Procedures National Academy of Science</source>
<volume>75</volume>: <fpage>6332</fpage>&#x02013;<lpage>6336</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.75.12.6332</pub-id></mixed-citation></ref><ref id="bib12"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name>, <name name-style="western"><surname>Handsaker</surname><given-names>B.</given-names></name>, <name name-style="western"><surname>Wysoker</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Fennel</surname><given-names>T.</given-names></name>, <name name-style="western"><surname>Ruan</surname><given-names>J.</given-names></name><etal/></person-group>, <year>2009</year>&#x02003;<article-title>The sequence alignment/map format and SAMtools</article-title>. <source>Bioinformatics</source>
<volume>25</volume>: <fpage>2078</fpage>&#x02013;<lpage>2079</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btp352</pub-id><pub-id pub-id-type="pmid">19505943</pub-id></mixed-citation></ref><ref id="bib13"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Peng</surname><given-names>B.</given-names></name>, <name name-style="western"><surname>Chen</surname><given-names>H. S.</given-names></name>, <name name-style="western"><surname>Mechanic</surname><given-names>L. E.</given-names></name>, <name name-style="western"><surname>Racine</surname><given-names>B.</given-names></name>, <name name-style="western"><surname>Clarke</surname><given-names>J.</given-names></name><etal/></person-group>, <year>2015</year>&#x02003;<article-title>Genetic data simulators and their applications: an overview</article-title>. <source>Genet. Epidemiol.</source>
<volume>39</volume>: <fpage>2</fpage>&#x02013;<lpage>10</lpage>. <pub-id pub-id-type="doi">10.1002/gepi.21876</pub-id><pub-id pub-id-type="pmid">25504286</pub-id></mixed-citation></ref><ref id="bib14"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Purcell</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Neale</surname><given-names>B.</given-names></name>, <name name-style="western"><surname>Todd-Brown</surname><given-names>K.</given-names></name>, <name name-style="western"><surname>Thomas</surname><given-names>L.</given-names></name>, <name name-style="western"><surname>Ferreira</surname><given-names>M. A. R.</given-names></name><etal/></person-group>, <year>2007</year>&#x02003;<article-title>Plink: a toolset for whole-genome association and population-based linkage analysis</article-title>. <source>Am. J. Hum. Genet.</source>
<volume>81</volume>: <fpage>559</fpage>&#x02013;<lpage>575</lpage>. <pub-id pub-id-type="doi">10.1086/519795</pub-id><pub-id pub-id-type="pmid">17701901</pub-id></mixed-citation></ref></ref-list></back></article>