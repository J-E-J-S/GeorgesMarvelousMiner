<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?><?DTDIdentifier.IdentifierType public?><?SourceDTD.DTDName A++V2.4.dtd?><?SourceDTD.Version 2.4?><?ConverterInfo.XSLTName springer2nlmx2.xsl?><?ConverterInfo.Version 1?><front><journal-meta><journal-id journal-id-type="nlm-ta">Sci Rep</journal-id><journal-id journal-id-type="iso-abbrev">Sci Rep</journal-id><journal-title-group><journal-title>Scientific Reports</journal-title></journal-title-group><issn pub-type="epub">2045-2322</issn><publisher><publisher-name>Nature Publishing Group UK</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">6416333</article-id><article-id pub-id-type="publisher-id">40739</article-id><article-id pub-id-type="doi">10.1038/s41598-019-40739-8</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Featherweight long read alignment using partitioned reference indexes</article-title></title-group><contrib-group><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-9034-9905</contrib-id><name><surname>Gamaarachchi</surname><given-names>Hasindu</given-names></name><xref ref-type="aff" rid="Aff1">1</xref><xref ref-type="aff" rid="Aff2">2</xref></contrib><contrib contrib-type="author"><name><surname>Parameswaran</surname><given-names>Sri</given-names></name><xref ref-type="aff" rid="Aff2">2</xref></contrib><contrib contrib-type="author" corresp="yes"><name><surname>Smith</surname><given-names>Martin A.</given-names></name><address><email>martinalexandersmith@gmail.com</email></address><xref ref-type="aff" rid="Aff1">1</xref><xref ref-type="aff" rid="Aff3">3</xref></contrib><aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0000 9983 6924</institution-id><institution-id institution-id-type="GRID">grid.415306.5</institution-id><institution>Kinghorn Centre for Clinical Genomics, </institution><institution>Garvan Institute of Medical Research, </institution></institution-wrap>370 Victoria St, Darlinghurst, NSW Australia </aff><aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 4902 0432</institution-id><institution-id institution-id-type="GRID">grid.1005.4</institution-id><institution>School of Computer Science and Engineering, </institution><institution>UNSW Sydney, </institution></institution-wrap>Kensington, NSW Australia </aff><aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 4902 0432</institution-id><institution-id institution-id-type="GRID">grid.1005.4</institution-id><institution>St-Vincent&#x02019;s Clinical School, Faculty of Medicine, </institution><institution>UNSW Sydney, </institution></institution-wrap>Darlinghurst, NSW Australia </aff></contrib-group><pub-date pub-type="epub"><day>13</day><month>3</month><year>2019</year></pub-date><pub-date pub-type="pmc-release"><day>13</day><month>3</month><year>2019</year></pub-date><pub-date pub-type="collection"><year>2019</year></pub-date><volume>9</volume><elocation-id>4318</elocation-id><history><date date-type="received"><day>20</day><month>8</month><year>2018</year></date><date date-type="accepted"><day>22</day><month>2</month><year>2019</year></date></history><permissions><copyright-statement>&#x000a9; The Author(s) 2019</copyright-statement><license license-type="OpenAccess"><license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The images or other third party material in this article are included in the article&#x02019;s Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the article&#x02019;s Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this license, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p></license></permissions><abstract id="Abs1"><p id="Par1">The advent of Nanopore sequencing has realised portable genomic research and applications. However, state of the art long read aligners and large reference genomes are not compatible with most mobile computing devices due to their high memory requirements. We show how memory requirements can be reduced through parameter optimisation and reference genome partitioning, but highlight the associated limitations and caveats of these approaches. We then demonstrate how these issues can be overcome through an appropriate merging technique. We incorporated multi-index merging into the Minimap2 aligner and demonstrate that long read alignment to the human genome can be performed on a system with 2&#x02009;GB RAM with negligible impact on accuracy.</p></abstract><custom-meta-group><custom-meta><meta-name>issue-copyright-statement</meta-name><meta-value>&#x000a9; The Author(s) 2019</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="Sec1" sec-type="introduction"><title>Introduction</title><p id="Par2">Long read sequencing has revolutionised genome research by facilitating the characterisation of large structural variations, repetitive regions, and de-novo assembly of whole genomes. Pacific Biosciences (PacBio) and Oxford Nanopore Technologies (ONT) are leading manufacturers that produce long read sequencers. In particular, ONT manufacture sequencers smaller than the size of a mobile phone that can nevertheless output more than 1&#x02009;TB of data in 48&#x02009;hours. Such highly portable sequencers have realised the possibility of performing genome sequencing in the field. For instance, ONT&#x02019;s MinION sequencer has been used for Ebola virus surveillance in New Guinea<sup><xref ref-type="bibr" rid="CR1">1</xref></sup>, mobile Zika virus surveillance in Brazil<sup><xref ref-type="bibr" rid="CR2">2</xref></sup>, and for experiments on the International space station<sup><xref ref-type="bibr" rid="CR3">3</xref></sup>.</p><p id="Par3">The advent of highly portable DNA sequencers raises the need for local data processing on devices such as mobile phones, tablets and laptops. Facilitating genomic data analysis on mobile devices avoids the need for high speed internet connections and enables real-time genomic tests and experiments. For Nanopore sequencers, a pico-ampere ionic current signal is produced for each DNA read, which is subsequently converted to nucleotide bases via applied machine learning models. Until recently, a high performance workstation (Quad-core i7 or Xeon processor, 16&#x02009;GB RAM, 1&#x02009;TB SSD) was required for live base calling, the process of converting ionic signal to nucleotide sequences.</p><p id="Par4">Most genomic analyses depend on base calling as an initial step, which can be efficiently performed through GPGPU software implementations on graphics cards or, quite conveniently, on dedicated portable hardware (ONT manufacture one such device, termed &#x02018;MinIT&#x02019;). Next, base called reads are typically aligned/mapped to a reference, in the&#x000a0;case of reference guided assembly, or aligned to themselves in the&#x000a0;case of de-novo assembly. Subsequent analyses (i.e. consensus sequence generation, variant calling, methylation detection, etc) should follow this alignment step. Therefore, an alignment tool that can run on portable devices such as mobile phones, tablets and laptops is the next step in realising the full portability of a complete Nanopore processing pipeline.</p><p id="Par5">Minimap2<sup><xref ref-type="bibr" rid="CR4">4</xref></sup> is a general purpose mapper/aligner that is compatible with both DNA and RNA sequences. Minimap2 can align both long reads and short reads, either to a reference or an assembly contig. Minimap2 first employs hashing followed by chaining for coarse-grained alignment. Then it performs an optional base level alignment using an optimised implementation of the Suzuki-Kasahara Dynamic Programming (DP) formulation<sup><xref ref-type="bibr" rid="CR5">5</xref></sup>. Minimap2 stands out as the current aligner of choice for long reads, among other long read aligners such as BLASR<sup><xref ref-type="bibr" rid="CR6">6</xref></sup>, GraphMap<sup><xref ref-type="bibr" rid="CR7">7</xref></sup>, Kart<sup><xref ref-type="bibr" rid="CR8">8</xref></sup>, NGMLR<sup><xref ref-type="bibr" rid="CR9">9</xref></sup> and LAMSA<sup><xref ref-type="bibr" rid="CR10">10</xref></sup>; not only is it 30 times faster than existing long read aligners, but its accuracy is on par or superior to other algorithms<sup><xref ref-type="bibr" rid="CR4">4</xref></sup>. The hash table based approach in Minimap2 has been&#x000a0;shown to be effective for long reads. In contrast, FM-index<sup><xref ref-type="bibr" rid="CR11">11</xref></sup> based short read aligners such as BWA<sup><xref ref-type="bibr" rid="CR12">12</xref></sup> and Bowtie<sup><xref ref-type="bibr" rid="CR13">13</xref></sup> have been&#x000a0;shown to fail with ultra long reads (i.e. several hundred kilobases or more)<sup><xref ref-type="bibr" rid="CR14">14</xref></sup>.</p><p id="Par6">Most alignment tools build an index of reference sequences that is stored in volatile memory. Whilst this is manageable for small genomes such as individual bacteria (~5&#x02009;Mb), fungi (~50&#x02009;Mb) or insects (~400&#x02009;Mb), most vertebrates and some plant species require large amounts of memory, as their genomes are in the 1&#x02013;100&#x02009;Gb range. For example, building an index for the GRCh38 human genome reference requires over 11.2&#x02009;GB of volatile memory, and at the very least 8.8&#x02009;GB to map nanopore reads to a pre-computed index with Minimap2.</p><p id="Par7">To accelerate the development and uptake of real-time genomic applications in field research and point of care medical testing, long read sequence alignment should be performed on ultra-portable computing devices. These can include mobile phones, microcomputer boards, Field-Programmable Gate Arrays (FPGAs), and other embedded systems, such as ONT&#x02019;s &#x0201c;MinIT&#x0201d; and &#x0201c;Mk1c MinION&#x0201d; devices. Such hardware rarely have more than 4&#x02009;GB of RAM, therefore more expensive and less portable equipment is typically required for sequence alignment (high-end laptops, internet connectivity, power generation, etc).</p><p id="Par8">Here, we describe strategies for long read alignment to large reference genomes (or collections of genomes) using low amounts of memory. We present an efficient approach to achieve this by splitting a genome index into smaller partitions. Although partitioned indexes are not a novel concept<sup><xref ref-type="bibr" rid="CR15">15</xref>&#x02013;<xref ref-type="bibr" rid="CR17">17</xref></sup>, we expose the caveats of their use on the accuracy of entailing alignments. We present a solution to these issues by merging multi-part alignments via serialisation of internal data structures of the Minimap2 aligner, and demonstrate how this strategy produces alignments that are almost indiscernible from a classical single index using simulated long reads, Nanopore NA12878 reference human genome sequencing data, and a 470&#x02009;kb long chromothriptic read from a human cancer cell line.</p></sec><sec id="Sec2" sec-type="results"><title>Results</title><sec id="Sec3"><title>Effect of parameters on memory usage</title><p id="Par9">With default options, Minimap2 requires more than 11&#x02009;GB of memory to create an index from the human reference genome sequence and align Nanopore reads against it (Supplementary Table&#x000a0;<xref rid="MOESM1" ref-type="media">S1</xref>). Although the pre-calculated index can be saved to disk, 7.7&#x02009;GB are nonetheless required to subsequently load the index into memory, and between 8.8 and 11.3&#x02009;GB are required when intermediate data structures during alignment are included. This exceeds the average RAM capacities of high-end mobile phones and mid-range laptops. Hence, running Minimap2 on human data with default options on a typical laptop with 8&#x02009;GB memory or a typical mobile phone with 2&#x02009;GB of memory is not feasible.</p><p id="Par10">We therefore tested the relative effect of alignment parameters on peak memory usage in Minimap2 (see Materials and methods) to investigate if parameter optimisation alone can significantly reduce the memory requirements without compromising alignment quality. For this purpose, we used Sequins&#x02014;synthetic DNA spike-in controls that are designed from the reverse or &#x02018;mirrored&#x02019; human genome sequence<sup><xref ref-type="bibr" rid="CR18">18</xref></sup>. This chirality reproduces diverse properties of the human genome, such as nucleotide frequencies, complexity, repetitiveness, somatic variation, etc. As detailed in Materials and methods, we aligned Nanopore sequencing data from Sequins to both native and reversed (not complemented) human reference genomes to compare the relative impact of Minimap2 parameters on alignment accuracy. Specifically:<list list-type="bullet"><list-item><p id="Par11"><italic>k</italic> the minimiser k-mer length (default&#x02009;=&#x02009;15 for ONT data);</p></list-item><list-item><p id="Par12"><italic>w</italic> the minimiser window size (default&#x02009;=&#x02009;10);</p></list-item><list-item><p id="Par13"><italic>t</italic> the number of threads (default&#x02009;=&#x02009;4);</p></list-item><list-item><p id="Par14"><italic>K</italic> the number of query bases loaded into memory at a time (default&#x02009;=&#x02009;500&#x02009;M).</p></list-item></list></p><p id="Par15">Parameters <italic>k</italic> and <italic>w</italic> considerably affect the peak memory usage for holding the index in memory (Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1a</xref>). For an index without homo-polymer compression, <italic>k</italic>&#x02009;=&#x02009;15 consumed the least amount of memory out of the values tested, as expected. In fact, the default k-mer size for ONT data in Minimap2 (pre-set command line parameter <italic>map-ont</italic>) is 15.<fig id="Fig1"><label>Figure 1</label><caption><p>Effect of parameters on memory usage, performance and accuracy. (<bold>a</bold>) Peak memory usage of the index for different combinations of <italic>k</italic> and <italic>w</italic>. (<bold>b</bold>) Peak memory usage of the index for a large range of <italic>w</italic> with <italic>k</italic>&#x02009;=&#x02009;15. (<bold>c</bold>) The effect of <italic>w</italic> on sensitivity and error relative to the default window size. The x-axis is the minimiser window size (<italic>w</italic>). The k-mer size is held constant at 15 for all values of <italic>w</italic>. The y-axis shows the number of missing mappings/mismatches or extra mapping (compared to the mappings from default <italic>w</italic>&#x02009;=&#x02009;10) as a percentage of the number of reads. (<bold>d</bold>) Distribution of the dynamic programming alignment score for different minimiser window sizes (<italic>w</italic>). The x-axis is the score and the y-axis is the smoothed number of mappings for a particular score. Note that the distribution is smoothed to show the trend. (<bold>e</bold>) Effect of the number of threads on memory and performance. The parameters <italic>k</italic>, <italic>w</italic> and <italic>K</italic> were held constant at 15, 25 and 200&#x02009;M respectively while changing the number of threads. Both the peak memory usage and the runtime were measured on a PC with an Intel i7-6700&#x02009;CPU and 16&#x02009;GB of RAM. (<bold>f</bold>) Effect of the number of query bases loaded at a time. The parameters <italic>k</italic>, <italic>w</italic> and <italic>t</italic> were held constant at 15, 25 and 8 respectively.</p></caption><graphic xlink:href="41598_2019_40739_Fig1_HTML" id="d29e455"/></fig></p><p id="Par16">Unsurprisingly, parameter <italic>w</italic> has the most prominent impact on memory usage, which decreases considerably when increasing <italic>w</italic> (Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1b</xref>). At <italic>w</italic>&#x02009;=&#x02009;50, memory usage is capped at 3&#x02009;GB, but the sensitivity (see Materials and methods) is substantially reduced compared to the default value of parameter <italic>w</italic> (missing mappings in Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1c</xref>). A larger <italic>w</italic> of 50 reduces sensitivity compared to the default value of <italic>w</italic> by 20%, whereas a <italic>w</italic> of 25 entails an apparent reduction in sensitivity of about 7% while nonetheless requiring more than 4&#x02009;GB of memory. Although sufficient for a computer with 8&#x02009;GB of RAM, this is still too high for smaller devices.</p><p id="Par17">Importantly, the amount of mismatched mappings in mapped reads are not significantly affected by the <italic>w</italic> parameter (mismatches in Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1c</xref>), nor are the high-quality alignments as demonstrated by their dynamic programming (DP) alignment score distributions (cf. DP score&#x02009;&#x0003e;&#x02009;2000 in Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1d</xref>). However, lower (&#x02248;1000) DP scores are less frequent with increasing window size, as are alignments with high MAPQ scores, while those with low MAPQ scores are more prevalent (Supplementary Fig.&#x000a0;<xref rid="MOESM1" ref-type="media">S1</xref>). The effect of the window size is also apparent with simulated PacBio reads, where both the sensitivity and error-rate of alignments are negatively affected (Supplementary Fig.&#x000a0;<xref rid="MOESM1" ref-type="media">S2</xref>).</p><p id="Par18">The number of threads marginally increases peak memory usage (Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1e</xref>). Only about 0.8&#x02009;GB of additional memory was consumed when moving from 1 to 8 threads, while producing a 6-fold gain in speed. Hence, reducing the number of threads for the sake of reduced memory usage is not an efficient solution.</p><p id="Par19">Intuitively, the number of query bases loaded to the memory at once (also known as the mini-batch size) heavily impacts peak memory usage. This affects the size of the internal data structures used for mapping, but does not affect the index size. Hence, this parameter does not affect alignment accuracy or the sensitivity. A lower mini-batch size reduces the peak memory usage, at the cost of reduced multi-threading efficiency (Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1f</xref>). The runtime drops when changing the mini-batch size from 1&#x02009;M to 5&#x02009;M. However, the runtime is relatively stable from a mini-batch size of 5&#x02009;M onwards. It is important to note that the values in Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1f</xref> are only valid for 8 threads. A large number of threads would require a large mini-batch size for optimal performance.</p><p id="Par20">Although parameter adjustments (small minimiser window size value and mini-batch sizes from 5&#x02009;M&#x02013;20&#x02009;M in particular) can be suitable for systems with limited RAM (for 8&#x02009;CPU threads or less), tuning parameters alone cannot bring down the memory usage to a value lesser than 4&#x02009;GB due to a substantial loss of sensitivity. As a consequence, this inspired us to investigate the use and suitability of partitioning (or splitting) the reference sequences into distinct indexes.</p></sec><sec id="Sec4"><title>Caveats of naive partitioned indexes</title><p id="Par21">Minimap2 allows the reference index to be split by a user-specified number of bases through the option <italic>I</italic>, effectively dividing a reference into smaller indexes of comparable size. This facilitates parallel computation and, in theory, enables lower peak memory requirements. However, this feature is not ideal for mapping single reads to large references, mainly because global contiguous information about the reference is unavailable. As a result, several mapping artefacts can occur, as listed below and in Fig.&#x000a0;<xref rid="Fig2" ref-type="fig">2</xref> (N.B. these may not be as prominent when overlapping reads&#x02013;the application for which index partitioning in Minimap2 was originally developed).<list list-type="order"><list-item><p id="Par22">The mapping quality is incorrect.</p><p id="Par23">The mapping quality estimated in Minimap2 is accurate as it deliberately lowers the mapping quality for repetitive hits. However, this is not possible when only a fraction of a whole genome is present in the index (see Supplementary Materials of Li, H.<sup><xref ref-type="bibr" rid="CR4">4</xref></sup>). In a partitioned index, if the same repeat lies across different partitions, the mapping quality will be overestimated (Fig.&#x000a0;<xref rid="Fig2" ref-type="fig">2b</xref>).</p></list-item><list-item><p id="Par24">Incorrect alignment flags.</p><p id="Par25">For a chimeric read where different sub-sequences map to different chromosomes, the supplementary mappings would be marked as primary mappings (Fig.&#x000a0;<xref rid="Fig2" ref-type="fig">2a</xref>). A repeat-containing read that maps to multiple locations across different partitions will have multiple primary alignments instead of a single primary alignment (Fig.&#x000a0;<xref rid="Fig2" ref-type="fig">2b,c</xref>).</p></list-item><list-item><p id="Par26">Large output files.</p><p id="Par27">A spurious unmapped record will be printed for each partition of the index where a particular read does not map to. Furthermore, if a maximal amount of secondary alignments are specified, that number of secondary alignments would be output for each partition (Fig.&#x000a0;<xref rid="Fig2" ref-type="fig">2c</xref>). Hence, the more partitions used, the larger the output files will be. Such large outputs not only waste disk space, but they are also time consuming to parse or sort.</p></list-item><list-item><p id="Par28">Multiple hits of the same query may not be adjacent in the output<sup><xref ref-type="bibr" rid="CR19">19</xref></sup>.</p><p id="Par29">This causes difficulties to analyse or evaluate mapping results. For instance, the <italic>Mapeval</italic> utility in <italic>Paftools</italic> (a tool bundled with Minimap2 for evaluating alignment accuracy) is not compatible with such outputs. Sorting by the read identifier would fix the issue, but requires significant computation for large files.</p></list-item><list-item><p id="Par30">Incomplete headers in the sequence alignment/map (SAM) output.</p></list-item></list><fig id="Fig2"><label>Figure 2</label><caption><p>Effect of aligning sequences to single vs partitioned indexes. Uniquely mapping chimeric reads (<bold>a</bold>) can be reconstructed from a partitioned reference index with relative ease. However, sequences (or sub-sequences) that are difficult to map (i.e. low complexity regions, repetitive elements, etc) can cause artefacts when aligning to a partitioned reference index. (<bold>b</bold>) An example where one partition (chr2) contains less homologous sequences to the query sequence, producing the situation where the best alignment when using a single reference is not achieved. (<bold>c</bold>) An example where a partitioned reference introduces several additional low quality mappings that would be dismissed with a single reference index. <italic>Q</italic>: mapping quality score.</p></caption><graphic xlink:href="41598_2019_40739_Fig2_HTML" id="d29e614"/></fig></p><p id="Par31">&#x02002;&#x02009;For a partitioned index, Minimap2 suppresses the reference sequence dictionary (SQ lines) in the SAM header. Users must manually add SQ lines to the header for compatibility with downstream analysis tools.</p><p id="Par32">We resolved these issues by serialising and storing the internal state of Minimap2 while mapping reads, then merging the output and processing the result <italic>a posteriori</italic> (see Materials and methods). The accuracy of this technique is discussed below.</p></sec><sec id="Sec5"><title>Effect of using a partitioned index on alignment accuracy</title><p id="Par33">We compared the alignment accuracy between a single reference index and a partitioned index, with and without merging the output. The following acronyms will be used in the subsequent text (see Materials and methods for more details):<list list-type="bullet"><list-item><p id="Par34"><italic>single-idx</italic>: Aligning reads to a single reference index;</p></list-item><list-item><p id="Par35"><italic>part-idx-no-merge</italic>: Aligning reads to a partitioned index without merging the output;</p></list-item><list-item><p id="Par36"><italic>part-idx-merged</italic>: Aligning reads to a partitioned index while applying our merging technique.</p></list-item></list></p><sec id="Sec6"><title>Synthetic long reads</title><p id="Par37">Synthetic long reads were used as a ground truth for the evaluation of alignment accuracy (see Materials and methods). The accuracy of <italic>part-idx-merged</italic> is similar to <italic>single-idx</italic>, despite employing significantly more partitions (Fig.&#x000a0;<xref rid="Fig3" ref-type="fig">3a,b</xref>) as exemplified by the overlap of their respective curves. In contrast, the results of <italic>part-idx-no-merge</italic> are considerably less accurate, in particular for larger quantities of index partitions. A lower error rate is observed for <italic>part-idx-merged</italic> when compared to <italic>single-idx</italic> for the lowest mapping quality values, but this effect is marginal and is associated with low sensitivity.<fig id="Fig3"><label>Figure 3</label><caption><p>Effect of using partitioned indexes versus a single reference index on alignment quality. (<bold>a</bold>) Base-level and (<bold>b</bold>) locus- or block-level alignment accuracy from synthetic long reads. The x-axis shows the error rate of alignments in log scale (see Materials and methods). The y-axis shows the fraction of aligned reads out of all input reads. Each point in the plot corresponds to a mapping quality threshold that varies from 0 (top right) to 60 (bottom left). These plots are akin to precision-recall plots with the x-axis inverted. (<bold>c</bold> and <bold>d</bold>) Alignment statistics for Nanopore whole genome sequencing data from NA12878<sup><xref ref-type="bibr" rid="CR14">14</xref></sup> using a 16-part index. (<bold>c</bold>) The number of total entries (primary&#x02009;+&#x02009;secondary&#x02009;+&#x02009;unaligned) for <italic>single-idx</italic>, <italic>16-part-idx-merged</italic>, and <italic>16-part-idx-no-merge</italic>, in log scale. The dotted horizontal line represents the number of reads. (<bold>d</bold>) Number of primary mappings in function of Minimap2 mapping quality (log scale).</p></caption><graphic xlink:href="41598_2019_40739_Fig3_HTML" id="d29e707"/></fig></p></sec><sec id="Sec7"><title>For real Nanopore NA12878 reads</title><p id="Par38">As no ground truth is available for biological data, we evaluated alignment accuracy by comparing the number of primary/secondary alignments and unmapped reads across single and multi-partition indexes. When using <italic>single-idx</italic>, Minimap2 outputs 12.1&#x02009;GB of base-level alignment data in SAM format, whereas <italic>part-idx-no-merge</italic> generates much larger output (180&#x02009;GB). However, <italic>part-idx-merged</italic> generates 12.4&#x02009;GB of data&#x02013;proportional to the output produced with <italic>single-idx</italic>. Hence, <italic>part-idx-merged</italic> reduces disk usage by about 14-fold compared to <italic>part-idx-no-merge</italic>. Peak disk usage is also minimised in <italic>part-idx-merged</italic> as only intermediate alignments are serialised as temporary binary files. The resulting size of temporary files generated with <italic>part-idx-merged</italic> is 29.2&#x02009;GB, thus achieving maximal disk usage of 41.6&#x02009;GB, 4&#x02009;times less than <italic>part-idx-no-merge</italic>. The increased output produced by <italic>part-idx-no-merge</italic> is due to redundant unmapped entries and spurious mappings (Fig.&#x000a0;<xref rid="Fig3" ref-type="fig">3c</xref> and Supplementary Table&#x000a0;<xref rid="MOESM1" ref-type="media">S2</xref>).</p><p id="Par39">The number of total entries (primary&#x02009;+&#x02009;secondary&#x02009;+&#x02009;unaligned) for <italic>single-idx</italic> and <italic>part-idx-merged</italic> are comparable to the number of input reads (689,781), while <italic>part-idx-no-merge</italic> generates abundant&#x02014;presumably spurious&#x02014;hits. Furthermore, the distribution of mapping qualities for primary alignments between <italic>part-idx-merged</italic> and <italic>single-idx</italic> are quite similar (Fig.&#x000a0;<xref rid="Fig3" ref-type="fig">3d</xref>). Interestingly, <italic>part-idx-merged</italic> produces slightly more primary alignments with lower mapping quality scores than <italic>single-idx</italic>, a likely consequence of sampling less repetitive regions in partitioned indexes. All the strategies produce almost the same amount of mappings with quality&#x02009;=&#x02009;60. In contrast, <italic>part-idx-no-merge</italic> has a very high number of spurious mappings for mapping qualities between 0 to 59.</p><p id="Par40">A more detailed comparison of 689,781&#x02009;ONT reads aligned using <italic>single-idx</italic> and <italic>16-part-idx-merged</italic> revealed the following: 120,623 (17.49%) reads were unmapped in both; 152 (0.02%) reads mapped only in <italic>single-idx</italic>; 6,554 (0.95%) reads mapped only in <italic>16-part-idx-merged</italic>; 562,452 (81.54%) reads mapped in both. Less than 1% of all reads presented discordant mappings when using a single or a multi-part index. Of those discordant mappings, 6,423 (95.8%) overlapped regions in the human genome annotative as repeat elements or low-complexity sequences, the majority of which were satellites and ALR/Aplha repeats from centromeres (Supplementary Figs&#x000a0;<xref rid="MOESM1" ref-type="media">S3</xref> and <xref rid="MOESM1" ref-type="media">S4</xref>). Furthermore, most (97.7%) of these index-specific unique alignments stem from the multi-part index, which suggests that a reduced search space can help Minimap2 map less complex sequences, presumably through more frequent recourse of the dynamic programming step in Minimap2.</p><p id="Par41">Among the 562,452 reads that mapped in both <italic>single-idx</italic> and <italic>16-part-idx-merged</italic>, 545,306 (96.95%) had the exact same primary mappings (same chromosome, strand and position). Out of the remaining 17,146 aligned reads (3.05%): 2,748 (16.02%) of mapping coordinates overlapped by at least 10% in both sets; 952 (5.55%) were classified as supplementary mappings in <italic>16-part-idx-merged</italic> and as&#x000a0;primary mappings in <italic>single-idx</italic>; 3,891 (22.69%) were classified as secondary mappings in <italic>16-part-idx-merged</italic> and as&#x000a0;primary mappings in <italic>single-idx</italic>.</p><p id="Par42">Of the 17,146 reads with disparate mappings, 50.5% had higher DP alignment scores for the single index, while 42.9% had higher scores in the 16-part index (Pearson&#x02019;s correlation&#x02009;=&#x02009;0.93, Supplementary Figs&#x000a0;<xref rid="MOESM1" ref-type="media">S5</xref> and <xref rid="MOESM1" ref-type="media">S6</xref>). This effect was similarly observed for MAPQ scores, with 15.2% and 12.8%, respectively, suggesting that alignments are of marginally better quality when generated with a single index. Again, these disparate mappings are largely composed of repetitive and viral sequences (Supplementary Fig.&#x000a0;<xref rid="MOESM1" ref-type="media">S7</xref>). When the 2,748 overlapped reads were removed from the 17,146 disparate mappings, the trend of DP scores, MAPQs, and repeat distributions are very similar to when those are not removed (Supplementary Fig.&#x000a0;<xref rid="MOESM1" ref-type="media">S8</xref>).</p></sec><sec id="Sec8"><title>For an ultra-long chromothriptic read</title><p id="Par43">To evaluate how chimeric reads will be affected by aligning them to partitioned indexes, we tested this case on an ultra-long (473&#x02009;kb) chromothriptic ONT read from a patient-derived liposarcoma cell line<sup><xref ref-type="bibr" rid="CR20">20</xref></sup>. Chromothripsis is a genetic phenomenon often associated with cancer and congenital diseases. It is caused by several rounds of breakage-fusion-bridge, which produce complex and localised genomic rearrangements in a relatively short segment of DNA. The <italic>single-idx</italic> produced 41 (36 primary&#x02009;+&#x02009;5 secondary mappings) mappings (Fig.&#x000a0;<xref rid="Fig4" ref-type="fig">4a</xref>). However, <italic>part-idx-no-merge</italic> (16 partitions) produced 688 (608 primary&#x02009;+&#x02009;80 secondary) mappings (Fig.&#x000a0;<xref rid="Fig4" ref-type="fig">4b</xref>), while mapping with <italic>part-idx-merged</italic> resulted in 47 (42 primary&#x02009;+&#x02009;5 secondary) mappings (Fig.&#x000a0;<xref rid="Fig4" ref-type="fig">4c</xref>).<fig id="Fig4"><label>Figure 4</label><caption><p>Alignment of an ultra-long ONT read from a chromothriptic region. Mapping coordinates in the entire human reference genome (y-axis) in function of the position in the read, showing where sub-sequences of the chimeric read map in the genome for (<bold>a</bold>) <italic>single-idx</italic>, (<bold>b</bold>) <italic>part-idx-no-merge</italic>, and (<bold>c</bold>) <italic>part-idx-merged</italic>. The y-axis begins with chromosome 1 at 0 and ends with chromosome X, Y, and the mitochondria at the top. The length of rectangles along the x-axis are in the correct scale to the length of the read. However, the length along the y-axis are exaggerated to a fixed value so that it is clearly visible. In (<bold>a</bold> and <bold>c</bold>), the areas with dotted circles contain the differences between unique mappings for each alignment strategy. Circled regions in (<bold>a</bold>) map to a genomic locus harbouring the satellite repeat displayed in (<bold>d</bold>). Out of the 6 unique mappings in (<bold>c</bold>), the segment with the highest mapping quality (6) maps to the simple repeat containing region displayed in (<bold>e</bold>).</p></caption><graphic xlink:href="41598_2019_40739_Fig4_HTML" id="d29e911"/></fig></p><p id="Par44">In <italic>single-idx</italic> and <italic>part-idx-merged</italic>, 34 mappings were the same. Interestingly, there were 7 mappings unique to <italic>single-idx</italic> and 6 unique to <italic>part-idx-merged</italic> (Supplementary Table&#x000a0;<xref rid="MOESM1" ref-type="media">S3</xref>). All 7 alignments unique to <italic>single-idx</italic> map to the centromeric region of chromosome 11 (Fig.&#x000a0;<xref rid="Fig4" ref-type="fig">4d</xref>), which is composed of large arrays of repetitive DNA (also known as satellite DNA). The alignments that are unique to <italic>part-idx-merged</italic> map to simple repeats (e.g. GAGAGAGA).</p></sec></sec><sec id="Sec9"><title>Memory usage and runtime of partitioned indexes</title><p id="Par45">In addition to comparable quality of alignments, using a partitioned index yields impressive reductions on peak memory usage during indexing. About 7.7&#x02009;GB of memory is required to hold a single reference index, whereas only 1.5&#x02009;GB is needed for a partitioned index with 16 parts (Fig.&#x000a0;<xref rid="Fig5" ref-type="fig">5a</xref>). Peak memory usage can be further reduced by distributing or &#x02018;balancing&#x02019; chromosomes across partitions based on their size (see Materials and methods). These indexing approaches combined with a mini-batch size between 5&#x02013;20&#x02009;Mbases (Minimap2 parameter <italic>K</italic>) enables alignment of long reads to the human genome with less than 2&#x02009;GB of RAM. Although generating an index <italic>ab initio</italic> requires more memory than loading a pre-built one, this only needs to be done once for a given reference and can be performed <italic>a priori</italic>, if required.<fig id="Fig5"><label>Figure 5</label><caption><p>Peak memory usage and runtime for a partitioned index of the human genome. (<bold>a</bold>) Peak memory usage in function of the number of partitions for <italic>ab initio</italic> index generation (left) and loading a pre-built index (right). Dark bars represent memory usage when performing chromosome balancing as described herein, whilst light bars represent the&#x000a0;default iterative partition distribution as implemented in Minimap2. (<bold>b</bold>) Detailed runtime metrics for index building across two computational systems. <italic>System 1</italic> is a laptop with flash memory (Intel i7-8750H processor, 16&#x02009;GB of RAM and Toshiba XG5 series NVMe SSD) while <italic>system 2</italic> is a workstation with a mechanical hard disk (Intel i7-6700 processor, 16&#x02009;GB of RAM and Toshiba DT01ACA series HDD). The total indexing time has been broken down into three steps; <italic>chr balancing</italic>, <italic>index building</italic> and <italic>index concatenations</italic>. <italic>Chr balancing</italic> includes the overhead for chromosome sorting, partitioning and writing each partition to a separate file. (<bold>c</bold>) Runtime for base-level alignment (left) and block/locus level mapping (right). System 1 and 2 are as described in (<bold>b</bold>). Alignment was performed on the NA12878 data (see Materials and methods) with the <italic>map-ont</italic> pre-set in Minimap2 using 8 threads. Runtime statistics are composed of <italic>indexing</italic> (index generation including the overhead), <italic>mapping</italic> (total time for aligning reads to each partition), and <italic>merging</italic> using the method described herein. Runtimes include file reading and writing.</p></caption><graphic xlink:href="41598_2019_40739_Fig5_HTML" id="d29e1011"/></fig></p><p id="Par46">The reduced peak memory usage of a partitioned index comes with an inherent sacrifice in computing speed. Alignment requires significantly more time than the balancing, indexing and merging steps when generating an index <italic>ab initio</italic>, which we observed to be relatively constant across different partition ranges (Fig.&#x000a0;<xref rid="Fig5" ref-type="fig">5b</xref>). Less than 10% of the total compute time (5.7&#x02009;h) for base-level alignment is dedicated to balancing, indexing and merging when mapping to 16 partitions with eight CPU threads and a mechanical hard drive. When using flash memory, the overheads have very minor impact (3% of the total compute time). Chromosome balancing, for instance, required less than 1&#x02009;minute and merging required less than 2&#x02009;minutes.</p><p id="Par47">We observed that the alignment time increased less than linearly with the number of partitions in the index (Fig.&#x000a0;<xref rid="Fig5" ref-type="fig">5c</xref>). Since our motivation is to reduce the memory requirements of mapping to large references, this will inevitably impact speed. However, this also facilitates parallelisation of alignments, where several small index partitions can be distributed across an array of low-memory devices (e.g. microcomputing boards such as Raspberry Pi). It also enables the use of mobile computing devices, such mobile phone or inexpensive laptops, which would otherwise be impossible. Considering that ONT&#x02019;s MinION sequencer generates about 80% of all data in the first 24&#x02009;h, using 16 partitions would enable real-time mapping on a system with 2&#x02009;GB of RAM in parallel to data acquisition, whereas a system with 4&#x02009;GB RAM would only require 4 partitions and less than 1&#x02009;h of compute to align a typical ONT MinION dataset.</p></sec></sec><sec id="Sec10" sec-type="discussion"><title>Discussion</title><p id="Par48">This work details two ways to reduce memory requirements for performing alignments on large genomes, or collections of genomes, using Minimap2. By tuning alignment parameters, peak memory usage can be lowered marginally, although with non-negligible impact to the accuracy of alignments. We demonstrated this effect by sequencing and mapping a diverse and representative set of synthetic spike-in controls, which can be used as a ground truth to assess sequencing and alignment accuracy. However, these data were not used to benchmark the alignment accuracy of Minimap2, but to demonstrate the comparative and relative impact of alignment parameters on memory usage. In this regard, we show that partitioning a large reference into smaller indexes upstream of an appropriate merging process drastically reduces the peak memory usage without compromising alignment accuracy.</p><p id="Par49">Previous studies have described indexing strategies to improve computational efficiency. DIDA<sup><xref ref-type="bibr" rid="CR15">15</xref></sup> and DREAM-Yara<sup><xref ref-type="bibr" rid="CR16">16</xref></sup> use bloom filters to distribute sequencing reads to the most appropriate index partitions. However, these works employ methods&#x000a0;that are dependent on indexes generated with the Burrows-Wheeler transform algorithm,&#x000a0;which are ideal for short, less noisy reads generated by second generation sequencing platforms. These strategies focus on indexing enhancements centred on reducing the alignment search space by delivering reads to the most suitable index partition. Our work focuses on multi-index alignment merging, which is independent and complementary to these strategies. We reveal the problems derived from mapping to multiple partitions, such as the accuracy of mapping reads and the overestimation of the mapping quality. We show that our merging technique circumvents these issues via the analysis of mapping qualities and the use of independent controls. The partitioned reference approach has also been previously used for reducing the memory usage of BWA, a popular short read alignment program<sup><xref ref-type="bibr" rid="CR17">17</xref></sup>. However, the final output consists of the indiscriminate concatenation of the alignments from all the partitions, raising several of the caveats exposed in Fig.&#x000a0;<xref rid="Fig2" ref-type="fig">2</xref>. We have demonstrated that performing appropriate merging of alignment output is required to eliminate many mapping artefacts, thus improving overall accuracy.</p><p id="Par50">We also showed that <italic>part-idx-merged</italic> can provide a better result than a simple strategy of filtering out results with low mapping qualities in <italic>part-idx-no-merge</italic>. This is supported by the results from synthetic reads, where the accuracy of alignments with mapping quality 60 in <italic>part-idx-no-merge</italic> is lower than those from <italic>part-idx-merged</italic>. Furthermore, a simple strategy to remove all short mappings from <italic>part-idx-no-merge</italic> is also less than ideal. In fact, <italic>Paftools</italic> (which was used for evaluating the synthetic read alignments) considers the longest primary mapping when multiple primary mappings exist to assess alignment accuracy.</p><p id="Par51">However, <italic>part-idx-merged</italic> can sometimes generate non-identical alignments to that of <italic>single-idx</italic>. This is likely a consequence of slight variations in highly abundant k-mers observed during index construction. Overall, this affects only a few reads that would nonetheless have low mapping qualities&#x02013;an issue that has previously been reported by the author and users of Minimap2 (see the public code repository associated with Li, H.<sup><xref ref-type="bibr" rid="CR4">4</xref></sup>). Furthermore, the reported alignments might differ in long low-complexity regions, as Minimap2 may generate suboptimal alignments in long low-complexity regions (see Supplementary Materials of Li, H.<sup><xref ref-type="bibr" rid="CR4">4</xref></sup>).</p><p id="Par52">Although a partitioned index reduces peak memory usage, the runtime is proportionately higher. This is because all the reads should be repeatedly mapped to each partition of the reference. However, this strategy lends itself well to distributed computing, in particular when many smaller, less expensive computing devices are available.</p><p id="Par53">A limitation of this method also lies in the maximal number of partitions an index can be split into, which currently depends on the longest chromosome or contig. We have not yet investigated the impact of splitting chromosomes into fragments, although we anticipate this would not drastically affect results (as exemplified from the chromothriptic read example above). Furthermore, we have not tested the impact of this strategy for RNA sequencing read alignment, which implements different alignment scoring metrics.</p><p id="Par54">In addition to capability of mapping long reads to large genomes on devices with a small memory footprint, our extension to Minimap2 could potentially be useful for the following applications:<list list-type="bullet"><list-item><p id="Par55"><italic>Mapping to huge reference genome databases</italic>. Meta-genomic databases can be hundreds of gigabytes in size. Hence, holding the index for the whole database would be challenging even for high-specification servers. Especially when multiple species with similar genomes are present, an accurate mapping quality with correct flags, headers, and reduced output file sizes is always appreciated. Alternatively, mapping genome assembly contigs, or a select amount of long reads, to a large public sequence repository (akin to a BLASTN nucleotide databse query) could benefit from our approach. However, the effect of merging output from such large queries has yet to be investigated.</p></list-item><list-item><p id="Par56"><italic>Mapping with a lower window size for increased sensitivity</italic>. Minimap2 runs on a default minimiser window size of 10. However, reducing this value improves the mapping sensitivity, but increases the memory consumption. Our method can be beneficial&#x000a0;for applications where high sensitivity may be preferred, for instance, when confronted to&#x000a0;low coverage sequencing data.</p></list-item></list></p><p id="Par57">While preparing this manuscript, our method was integrated into the source code of the original Minimap2 software repository. In Minimap2 version 2.12, the option--<italic>split-prefix</italic> can be used to align to a partitioned index. The developer of Minimap2 has expanded our implementation to support paired end short reads and multi-threading for the merging process. The original version we implemented for conducting the above experiments is available in the associated <italic>github</italic> repository<sup><xref ref-type="bibr" rid="CR21">21</xref></sup> and can be useful for understanding the underlying algorithm. The partitioned index functionality can be invoked with the option--<italic>multi-prefix</italic>. Instructions to run the tools are detailed in the Supplementary Notes.</p></sec><sec id="Sec11" sec-type="materials|methods"><title>Materials and Methods</title><sec id="Sec12"><title>Exploration of parameters that affect memory usage in Minimap2</title><p id="Par58">For measuring peak memory usage and runtime, publicly available NA12878 ONT reads<sup><xref ref-type="bibr" rid="CR14">14</xref></sup> were aligned to the human genome reference (GRCh38) with Minimap2<sup><xref ref-type="bibr" rid="CR4">4</xref></sup>. Peak memory usage and runtime were measured by using the GNU command line <italic>time</italic> utility with the <italic>-v</italic> option.</p><p id="Par59">Sensitivity and error rate calculations for different window sizes (Minimap2 parameter <italic>w</italic>) were performed using Sequins, synthetic human genome spike-in controls and synthetic PacBio reads (see below). By reversing (not complementing) the sequences from regions of interest, these spike-in controls reproduce most features of the human genome, including nucleotide frequencies, somatic variation, low-complexity regions and repeats. Given their chiral or &#x02018;mirror&#x02019; design, Sequins do not align to the native reference sequence but will align to a mirror copy of the human reference genome. They can thus be used to benchmark alignment accuracy when spiked-in to a normal sample, although they were sequenced in isolation for this study. The particular Sequins design we employed was unpublished at the time this manuscript was prepared (Deveson <italic>et al</italic>., under review), but it is conceptually similar to what is reported by Deveson <italic>et al</italic>.<sup><xref ref-type="bibr" rid="CR18">18</xref></sup>. 1&#x02009;<italic>&#x003bc;</italic>g of Sequins DNA was sequenced on a ONT R9.4.1 flow cell, using the LSK108 sample preparation kit and the results were base called with ONT&#x02019;s proprietary Albacore software (version 1.2.6). Reads were mapped to the reverse human genome, using Minimap2 under the preset <italic>map-ont</italic> for different window sizes.</p><p id="Par60">We leveraged the chiral design of Sequins to qualify any mapping to the normal reference genome as a false positive. True positive Sequin alignments should display the exact mapping positions on the mirrored human genome, as intended by their design. However, given stochastic variations in sequencing (base calling idiosyncrasies, involuntary library fragmentation, sample degradation, etc) the primary mappings derived from the default window size parameter (<italic>w</italic>&#x02009;=&#x02009;10) in Minimap2 were used as a reference to assess the relative effect and impact of parameter tuning. Then, for a given window size:<list list-type="bullet"><list-item><p id="Par61"><italic>Mismatching mappings</italic> refer to primary mappings that had different positions to the mappings with reference parameters;</p></list-item><list-item><p id="Par62"><italic>Missing mappings</italic> refer to primary mappings that were not observed in empirical alignments, but were observed in alignments with reference parameters;</p></list-item><list-item><p id="Par63"><italic>Extra mappings</italic> refer to primary mappings that were observed in empirical alignments, but were not observed in alignments with reference parameters.</p></list-item></list></p><p id="Par64">The above counts were expressed as a percentage of the total number of reads. The sum of mismatch and extra mapping percentages was taken as an approximation of the relative error rate. The relative sensitivity was approximated by subtracting the percentage of missing mappings from 100.</p></sec><sec id="Sec13"><title>Merging of mappings from a partitioned index</title><p id="Par65">We extended the partitioned index approach of Minimap2 to eliminate alignment artefacts as described below. The index partitioning in Minimap2 is inherited from the first version of Minimap<sup><xref ref-type="bibr" rid="CR22">22</xref></sup>. This feature is for finding long read overlaps for use with assembly tools such as Miniasm<sup><xref ref-type="bibr" rid="CR22">22</xref></sup>. As overlap computing requires all-vs-all mapping of reads, the index is built for chunks of 4&#x02009;Gbases (can be overridden with the <italic>-I</italic> argument) at a time, effectively partitioning the alignment index to keep the maximum memory capped at around 27&#x02009;GB. For each part of the index, Minimap attempts to map all the reads. The concatenated alignments from all the parts is the final output.</p><p id="Par66">We modified Minimap2 to serialise and store the software&#x02019;s internal state during the alignment process. The internal state is serialised in binary format to reduce disk usage. The internal state includes: (i) mapped positions, chaining scores and other mapping statistics for each alignment record; (ii) DP score, CIGAR string, and other base-level alignment statistics for each alignment record (when base-level alignment is specified); and (iii) sum of region length of read covered by highly repetitive k-mers for each read (referred to as repeat length). These data form the serialised binary files, one for each partition of the index.</p><p id="Par67">When an alignment process has completed, we simultaneously open all the serialised binary files together with the queried sequence file. For each queried read (or contig), the previously serialised internal states of all alignments for the given read (resulting from all the index partitions) are loaded into memory. If no base-level alignment has been requested, the alignments are sorted based on the chaining score in descending order. Otherwise, the sorting is based on the DP alignment score in descending order. The classification of primary and secondary chains is reiterated as implemented in Minimap2. This corrects the primary and secondary flags in the output. Then, the secondary alignment entries are filtered based on a user requested number of secondary alignments, and the requested minimum primary to secondary score ratio, effectively removing spurious secondary alignments. If a SAM output has been requested, the best primary alignment is retained as the primary alignment and all other primary alignments are classified as supplementary alignments. An unaligned record is printed only if the read is not mapped to any part of the index.</p><p id="Par68">The length of the read covered by repeat regions in the whole genome (repeat length) is one of the parameters required to estimate an ideal mapping quality (MAPQ). The MAPQ produced by Minimap2 is a globally computed heuristic that depends on a large number of parameters, including this repeat length. We estimate this global repeat length by taking the maximum of the previously serialised repeat lengths (for each partition of the index) for that particular read. The Spearman correlation between this estimated repeat length and the global repeat length is 0.9961. In theory, it would possible to exactly calculate this value by serialising and storing the positions of repeats within the read. However, as the MAPQ is itself an estimation and the accuracy of mappings was adequate in our initial tests, we simply took the maximum. Hence, the computed MAPQ during merging of a partitioned index is not exactly the same as for a single reference index, but very similar overall. This computed MAPQ is more accurate than a MAPQ computed only from the repeat length for a single part of the index.</p><p id="Par69">Merging is performed in the order of input read sequences, and mappings for a particular read ID will be adjacent in the output. As the serialised data are loaded into memory for each read (or a batch of few reads) at a time, the memory usage of merging is only a few megabytes. For a detailed explanation of the merging algorithm refer to Supplementary Notes.</p></sec><sec id="Sec14"><title>Chromosome balancing</title><p id="Par70">The construction of partitioned indexes in Minimap2 (specified by the <italic>-I</italic> option) processes reference sequences iteratively, which does not distribute reference sequences (i.e. chromosomes) evenly when using multiple partitions. We implemented a simple sorting and binning algorithm to mitigate this effect. First, a command line parameter describing the number of desired partitions is considered. Then, the reference sequences (or chromosomes) are sorted in descending order of size. Next, a chromosome is assigned to the bin (or partition) with the lowest sum of bases, and the sum of that bin is then incremented by the chromosome size. This effectively distributes the chromosomes to roughly balanced partitions in <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathscr{O}}$$\end{document}</tex-math><mml:math id="M2"><mml:mi mathvariant="script">O</mml:mi></mml:math><inline-graphic xlink:href="41598_2019_40739_Article_IEq1.gif"/></alternatives></inline-formula>(<italic>n</italic>&#x02009;log&#x02009;<italic>n</italic>) time complexity&#x02013;adding negligible overhead to the overall indexing process (Supplementary Table&#x000a0;<xref rid="MOESM1" ref-type="media">S4</xref>). We output the reference sequences belonging to the each bucket in a separate file. Finally we launch the Minimap2 indexer on each file and concatenate the indexes. This approach is available under <italic>misc/idxtools</italic> in the <italic>github</italic> repository<sup><xref ref-type="bibr" rid="CR21">21</xref></sup> and the instructions to run the tool are detailed in Supplementary Notes.</p></sec><sec id="Sec15"><title>Datasets and evaluation methodology</title><p id="Par71">All experiments were performed using the human genome as a reference (GRCh38 with no ALT contigs). The scripts and tools written for performing the experiments are available under <italic>misc/idxtools/eval</italic> in the <italic>github</italic> repository<sup><xref ref-type="bibr" rid="CR21">21</xref></sup>.</p><sec id="Sec16"><title>Synthetic reads</title><p id="Par72">Mapping accuracy was evaluated using synthetic long reads. We generated about 4 million PacBio reads using PbSim<sup><xref ref-type="bibr" rid="CR23">23</xref></sup> under &#x0201c;Continuous Long Read&#x0201d; mode (long reads with a high error rate). The minimum, maximum and the mean read length were set to be 100&#x02009;bases, 25&#x02009;kbases and 3&#x02009;kbases respectively with a standard deviation of 2300. The minimum, maximum and the mean accuracy of bases were set to 0.75, 1.00 and 0.78 respectively with a standard deviation of 0.02. The ratio between substitution:insertion:deletion was 10:60:30.</p><p id="Par73">In the context of parameter tuning (Supplementary Fig.&#x000a0;<xref rid="MOESM1" ref-type="media">S2</xref>), the reads were mapped using Minimap2 with different window sizes while keeping other parameters constant. Then the accuracy evaluation was performed using the <italic>Mapeval</italic> utility in <italic>Paftools</italic>&#x02014;part of the Minimap2 software package&#x02014;where a read is considered correctly mapped if the mapping coordinates of its longest alignment overlap with the true reference coordinates with an overlap length of 10% or higher.</p><p id="Par74">In the context of multi-part index accuracy, simulated long reads were aligned using Minimap2 with single reference index (<italic>single-idx</italic>), partitioned index without merging (<italic>part-idx-no-merge</italic>) and partitioned index with merging (<italic>part-idx-merged</italic>). Partitioned indexes with 2, 4, 8 and 16 parts were tested. For each instance, we evaluated base-level alignments (default SAM output) as well as locus- or block-based alignments (default PAF output without CIGAR information). To evaluate alignment accuracy, the&#x000a0;<italic>Mapeval</italic> utility in <italic>Paftools</italic> was used with default options, which consider only the longest primary alignment for a read. However, <italic>Paftools</italic> assumes that all alignments for a particular read reside contiguously. Hence, for <italic>part-idx-no-merge</italic>, we first sorted the alignments based on the read ID. The output from <italic>Paftools</italic> contains the accumulative mapping error rate and the accumulative number of mapped reads for different mapping quality thresholds<sup><xref ref-type="bibr" rid="CR24">24</xref></sup>. The fraction of mapped reads is taken as a measure of sensitivity.</p></sec><sec id="Sec17"><title>Nanopore sequencing data</title><p id="Par75">We could not find a suitable ONT read simulator. Published ONT read simulators explored at the time of writing had issues such as dependence on Minimap2 (would cause a bias), unavailability of trained models for&#x000a0;the human genome, being unstable or unavailability of source code. For instance, DeepSimulator<sup><xref ref-type="bibr" rid="CR25">25</xref></sup> and NanoSim<sup><xref ref-type="bibr" rid="CR26">26</xref></sup> are dependent on Minimap2, SNaReSim<sup><xref ref-type="bibr" rid="CR27">27</xref></sup> code was not available. Hence, we used a a dataset from the publicly available NA12878 sample (rel3-nanopore-wgs-84868110-FAF01132<sup><xref ref-type="bibr" rid="CR14">14</xref></sup>). The dataset had 689,781 reads totaling about 5.5&#x02009;Gbases. We aligned this dataset to the human genome using a 16-part index with merging (<italic>part-idx-merged</italic>) and without merging (<italic>part-idx-no-merge</italic>) with base-level alignment. Then we compared those outputs by generating some alignment summary metrics with the result from a single reference index (<italic>single-idx</italic>). We initially attempted to perform an extensive comparison using tools such as the&#x000a0;<italic>CompareSAMs</italic> utility in <italic>Picard</italic><sup><xref ref-type="bibr" rid="CR28">28</xref></sup> and the&#x000a0;<italic>qProfiler</italic> utility in <italic>AdamaJava</italic><sup><xref ref-type="bibr" rid="CR29">29</xref></sup>, however, they crashed probably because they are designed to work with short reads. Hence, we first obtained simple summary metrics using <italic>samtools</italic><sup><xref ref-type="bibr" rid="CR30">30</xref></sup> together with custom Linux shell scripts. Then, we performed an extensive read by read comparison between the SAM outputs from <italic>single-idx</italic> and <italic>part-idx-merged</italic> using a custom tool written in C. The tool sequentially reads two SAM files while loading all the alignments for a particular read to the memory at a time. For a particular read, it compares and then outputs the alignment entries when the mapping positions between the two sets are disparate, or if they&#x000a0;mapped only in one set (discordant). On these disparate and discordant mappings, we used <italic>bedtools</italic><sup><xref ref-type="bibr" rid="CR31">31</xref></sup> to find overlaps with the UCSC Genome Browser&#x000a0;repeatMasker track.</p><p id="Par76">The above-mentioned NA12878 dataset was used to measure the runtime of partitioned indexes. The runtime and peak memory usage were measured using the GNU <italic>time</italic> command line utility.</p><p id="Par77">The ultra-long chromothriptic read was sourced from an unpublished patient-derived dataset generated in house (see Garsed <italic>et al</italic>.<sup><xref ref-type="bibr" rid="CR20">20</xref></sup> for more details on the cancer cell line). The data was generated on a MinION MkI sequencer (MN16218) with MinKNOW version 1.1.17 on a first generation R9 flowcell (MIN105, no spot-on loading, flow cell ID FAD24075) using the SQK-RAD001 library preparation kit from ONT. The raw data for the read was live base called with MinKNOW 1.1.17 and produced an average fastq score of 7.8.</p></sec></sec></sec><sec id="Sec18" sec-type="conclusion"><title>Conclusion</title><p id="Par78">Aligning long reads generated from third generation high-throughput sequencers to large reference genomes is possible on computers with limited volatile memory. Parameter optimisation alone cannot substantially reduce memory usage without considerably sacrificing alignment quality. Partitioning an alignment index, saving the internal state, and merging the output <italic>a posteriori</italic> substantially reduces memory usage. This strategy reduces the memory requirements for aligning ONT reads to the human reference genome from 11&#x02009;GB to less than 2&#x02009;GB, with minimal impact on accuracy.</p></sec><sec sec-type="supplementary-material"><title>Supplementary information</title><sec id="Sec19"><p>
<supplementary-material content-type="local-data" id="MOESM1"><media xlink:href="41598_2019_40739_MOESM1_ESM.pdf"><caption><p>Supplementary Information</p></caption></media></supplementary-material>
</p></sec></sec></body><back><fn-group><fn><p><bold>Publisher&#x02019;s note:</bold> Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p></fn></fn-group><sec><title>Supplementary information</title><p><bold>Supplementary information</bold> accompanies this paper at 10.1038/s41598-019-40739-8.</p></sec><ack><title>Acknowledgements</title><p>We thank Heng Li, the author of Minimap2 for assisting us in understanding the code, providing us with valuable insights and suggestions through Github issues, and integrating our method into his original software. We also thank Prof David Thomas, Prof Tony Papenfuss, Prof Vanessa Hayes and, in particular, Ruth Lyons for their assistance with generating sequencing data from which the (once record-holding) ultra-long chromothriptic Nanopore read was sourced.&#x000a0;We would like to thank Timothy Mercer and Ira Devenson for providing the Sequins spike-in controls, and Kirston Barton for her assistance in generating the&#x000a0;Sequins data.</p></ack><notes notes-type="author-contribution"><title>Author Contributions</title><p>H.G. and M.A.S. conceived the experiments, H.G. conducted the experiments, M.A.S. generated the chromothriptic read data. All authors analysed the results and reviewed the manuscript.</p></notes><notes notes-type="data-availability"><title>Data Availability</title><p>The datasets generated and analysed during the evaluation are available in the <italic>figshare</italic> repository<sup><xref ref-type="bibr" rid="CR32">32</xref></sup> [10.6084/m9.figshare.6964805.v1].</p></notes><notes notes-type="COI-statement"><sec id="FPar1"><title>Competing Interests</title><p>The authors declare no competing interests.</p></sec></notes><ref-list id="Bib1"><title>References</title><ref id="CR1"><label>1.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Quick</surname><given-names>J</given-names></name><etal/></person-group><article-title>Real-time, portable genome sequencing for Ebola surveillance</article-title><source>Nature</source><year>2016</year><volume>530</volume><fpage>228</fpage><pub-id pub-id-type="doi">10.1038/nature16996</pub-id><pub-id pub-id-type="pmid">26840485</pub-id></element-citation></ref><ref id="CR2"><label>2.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Faria</surname><given-names>NR</given-names></name><etal/></person-group><article-title>Mobile real-time surveillance of Zika virus in Brazil</article-title><source>Genome Medicine</source><year>2016</year><volume>8</volume><fpage>97</fpage><pub-id pub-id-type="doi">10.1186/s13073-016-0356-2</pub-id><?supplied-pmid 27683027?><pub-id pub-id-type="pmid">27683027</pub-id></element-citation></ref><ref id="CR3"><label>3.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Castro-Wallace</surname><given-names>SL</given-names></name><etal/></person-group><article-title>Nanopore DNA sequencing and genome assembly on the International Space Station</article-title><source>Scientific reports</source><year>2017</year><volume>7</volume><fpage>18022</fpage><pub-id pub-id-type="doi">10.1038/s41598-017-18364-0</pub-id><pub-id pub-id-type="pmid">29269933</pub-id></element-citation></ref><ref id="CR4"><label>4.</label><mixed-citation publication-type="other">Li, H. Minimap2: pairwise alignment for nucleotide sequences. <italic>Bioinformatics</italic> bty191, 10.1093/bioinformatics/bty191 (2018).</mixed-citation></ref><ref id="CR5"><label>5.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Suzuki</surname><given-names>H</given-names></name><name><surname>Kasahara</surname><given-names>M</given-names></name></person-group><article-title>Introducing difference recurrence relations for faster semi-global alignment of long sequences</article-title><source>BMC bioinformatics</source><year>2018</year><volume>19</volume><fpage>45</fpage><pub-id pub-id-type="doi">10.1186/s12859-018-2014-8</pub-id><pub-id pub-id-type="pmid">29504909</pub-id></element-citation></ref><ref id="CR6"><label>6.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chaisson</surname><given-names>MJ</given-names></name><name><surname>Tesler</surname><given-names>G</given-names></name></person-group><article-title>Mapping single molecule sequencing reads using basic local alignment with successive refinement (BLASR): application and theory</article-title><source>BMC bioinformatics</source><year>2012</year><volume>13</volume><fpage>238</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-13-238</pub-id><pub-id pub-id-type="pmid">22988817</pub-id></element-citation></ref><ref id="CR7"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sovi&#x00107;</surname><given-names>I</given-names></name><etal/></person-group><article-title>Fast and sensitive mapping of nanopore sequencing reads with GraphMap</article-title><source>Nature communications</source><year>2016</year><volume>7</volume><fpage>11307</fpage><pub-id pub-id-type="doi">10.1038/ncomms11307</pub-id></element-citation></ref><ref id="CR8"><label>8.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lin</surname><given-names>H-N</given-names></name><name><surname>Hsu</surname><given-names>W-L</given-names></name></person-group><article-title>Kart: a divide-and-conquer algorithm for NGS read alignment</article-title><source>Bioinformatics</source><year>2017</year><volume>33</volume><fpage>2281</fpage><lpage>2287</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btx189</pub-id><pub-id pub-id-type="pmid">28379292</pub-id></element-citation></ref><ref id="CR9"><label>9.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sedlazeck</surname><given-names>FJ</given-names></name><etal/></person-group><article-title>Accurate detection of complex structural variations using single-molecule sequencing</article-title><source>Nature Methods</source><year>2018</year><volume>15</volume><fpage>461</fpage><lpage>468</lpage><pub-id pub-id-type="doi">10.1038/s41592-018-0001-7</pub-id><?supplied-pmid 29713083?><pub-id pub-id-type="pmid">29713083</pub-id></element-citation></ref><ref id="CR10"><label>10.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>B</given-names></name><name><surname>Gao</surname><given-names>Y</given-names></name><name><surname>Wang</surname><given-names>Y</given-names></name></person-group><article-title>LAMSA: fast split read alignment with long approximate matches</article-title><source>Bioinformatics</source><year>2017</year><volume>33</volume><fpage>192</fpage><lpage>201</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btw594</pub-id><pub-id pub-id-type="pmid">27667793</pub-id></element-citation></ref><ref id="CR11"><label>11.</label><mixed-citation publication-type="other">Ferragina, P. &#x00026; Manzini, G. Opportunistic data structures with applications. In <italic>Foundations of Computer Science</italic>, <italic>2000</italic>. <italic>Proceedings</italic>. <italic>41st Annual Symposium on</italic>, 390&#x02013;398 (IEEE, 2000).</mixed-citation></ref><ref id="CR12"><label>12.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name></person-group><article-title>Fast and accurate short read alignment with Burrows&#x02013;Wheeler transform</article-title><source>Bioinformatics</source><year>2009</year><volume>25</volume><fpage>1754</fpage><lpage>1760</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id><pub-id pub-id-type="pmid">19451168</pub-id></element-citation></ref><ref id="CR13"><label>13.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Langmead</surname><given-names>B</given-names></name><name><surname>Trapnell</surname><given-names>C</given-names></name><name><surname>Pop</surname><given-names>M</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title><source>Genome biology</source><year>2009</year><volume>10</volume><fpage>R25</fpage><pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id><pub-id pub-id-type="pmid">19261174</pub-id></element-citation></ref><ref id="CR14"><label>14.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jain</surname><given-names>M</given-names></name><etal/></person-group><article-title>Nanopore sequencing and assembly of a human genome with ultra-long reads</article-title><source>Nature biotechnology</source><year>2018</year><volume>36</volume><fpage>338</fpage><pub-id pub-id-type="doi">10.1038/nbt.4060</pub-id></element-citation></ref><ref id="CR15"><label>15.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mohamadi</surname><given-names>H</given-names></name><etal/></person-group><article-title>Dida: Distributed indexing dispatched alignment</article-title><source>PloS one</source><year>2015</year><volume>10</volume><fpage>e0126409</fpage><pub-id pub-id-type="doi">10.1371/journal.pone.0126409</pub-id><pub-id pub-id-type="pmid">25923767</pub-id></element-citation></ref><ref id="CR16"><label>16.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dadi</surname><given-names>TH</given-names></name><etal/></person-group><article-title>Dream-yara: an exact read mapper for very large databases with short update time</article-title><source>Bioinformatics</source><year>2018</year><volume>34</volume><fpage>i766</fpage><lpage>i772</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bty567</pub-id><?supplied-pmid 30423080?><pub-id pub-id-type="pmid">30423080</pub-id></element-citation></ref><ref id="CR17"><label>17.</label><mixed-citation publication-type="other">Gnanasambandapillai, V., Bayat, A. &#x00026; Parameswaran, S. Mesga: An mpsoc based embedded system solution for short read genome alignment. In <italic>2018 23rd Asia and South Pacific Design Automation Conference</italic> (<italic>ASP-DAC</italic>), 52&#x02013;57, 10.1109/ASPDAC.2018.8297282 (2018).</mixed-citation></ref><ref id="CR18"><label>18.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Deveson</surname><given-names>IW</given-names></name><etal/></person-group><article-title>Representing genetic variation with synthetic dna standards</article-title><source>Nature methods</source><year>2016</year><volume>13</volume><fpage>784</fpage><pub-id pub-id-type="doi">10.1038/nmeth.3957</pub-id><pub-id pub-id-type="pmid">27502217</pub-id></element-citation></ref><ref id="CR19"><label>19.</label><mixed-citation publication-type="other">Li, H. minimap, <ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/minimap/blob/master/README.md">https://github.com/lh3/minimap/blob/master/README.md</ext-link> (2015).</mixed-citation></ref><ref id="CR20"><label>20.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Garsed</surname><given-names>DW</given-names></name><etal/></person-group><article-title>The architecture and evolution of cancer neochromosomes</article-title><source>Cancer Cell</source><year>2014</year><volume>26</volume><fpage>653</fpage><lpage>667</lpage><pub-id pub-id-type="doi">10.1016/j.ccell.2014.09.010</pub-id><pub-id pub-id-type="pmid">25517748</pub-id></element-citation></ref><ref id="CR21"><label>21.</label><mixed-citation publication-type="other">Li, H. <italic>et al</italic>. hasindu2008/minimap2-arm: long read alignment using partitioned reference indexes (version v0.1). <italic>github</italic>, 10.5281/zenodo.2011136 (2018).</mixed-citation></ref><ref id="CR22"><label>22.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name></person-group><article-title>Minimap and miniasm: fast mapping and de novo assembly for noisy\nlong sequences</article-title><source>Bioinformatics</source><year>2016</year><volume>32</volume><fpage>2103</fpage><lpage>2110</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btw152</pub-id><pub-id pub-id-type="pmid">27153593</pub-id></element-citation></ref><ref id="CR23"><label>23.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ono</surname><given-names>Y</given-names></name><name><surname>Asai</surname><given-names>K</given-names></name><name><surname>Hamada</surname><given-names>M</given-names></name></person-group><article-title>PBSIM: PacBio reads simulator&#x02014;toward accurate genome assembly</article-title><source>Bioinformatics</source><year>2012</year><volume>29</volume><fpage>119</fpage><lpage>121</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bts649</pub-id><pub-id pub-id-type="pmid">23129296</pub-id></element-citation></ref><ref id="CR24"><label>24.</label><mixed-citation publication-type="other">Li, H. Paftools, <ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/minimap2/blob/master/misc/README.md">https://github.com/lh3/minimap2/blob/master/misc/README.md</ext-link> (2018).</mixed-citation></ref><ref id="CR25"><label>25.</label><mixed-citation publication-type="other">Li, Y. <italic>et al</italic>. DeepSimulator: a deep simulator for Nanopore sequencing. <italic>Bioinformatics</italic> bty223, 10.1093/bioinformatics/bty223 (2018).</mixed-citation></ref><ref id="CR26"><label>26.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>C</given-names></name><name><surname>Chu</surname><given-names>J</given-names></name><name><surname>Warren</surname><given-names>RL</given-names></name><name><surname>Birol</surname><given-names>I</given-names></name></person-group><article-title>NanoSim: nanopore sequence read simulator based on statistical characterization</article-title><source>GigaScience</source><year>2017</year><volume>6</volume><fpage>1</fpage><lpage>6</lpage><?supplied-pmid 29149296?><pub-id pub-id-type="pmid">29149296</pub-id></element-citation></ref><ref id="CR27"><label>27.</label><mixed-citation publication-type="other">Faucon, P. C., Balachandran, P. &#x00026; Crook, S. SNaReSim: Synthetic Nanopore Read Simulator. In <italic>Healthcare Informatics</italic> (<italic>ICHI</italic>), <italic>2017 IEEE International Conference on</italic>, 338&#x02013;344 (IEEE, 2017).</mixed-citation></ref><ref id="CR28"><label>28.</label><mixed-citation publication-type="other">BroadInstitute. Picard, <ext-link ext-link-type="uri" xlink:href="http://broadinstitute.github.io/picard/">http://broadinstitute.github.io/picard/</ext-link> (2018).</mixed-citation></ref><ref id="CR29"><label>29.</label><mixed-citation publication-type="other">Adamajava, <ext-link ext-link-type="uri" xlink:href="https://github.com/AdamaJava/adamajava">https://github.com/AdamaJava/adamajava</ext-link> (2018).</mixed-citation></ref><ref id="CR30"><label>30.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name><etal/></person-group><article-title>The sequence alignment/map format and SAMtools</article-title><source>Bioinformatics</source><year>2009</year><volume>25</volume><fpage>2078</fpage><lpage>2079</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btp352</pub-id><pub-id pub-id-type="pmid">19505943</pub-id></element-citation></ref><ref id="CR31"><label>31.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Quinlan</surname><given-names>AR</given-names></name><name><surname>Hall</surname><given-names>IM</given-names></name></person-group><article-title>Bedtools: a flexible suite of utilities for comparing genomic features</article-title><source>Bioinformatics</source><year>2010</year><volume>26</volume><fpage>841</fpage><lpage>842</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btq033</pub-id><pub-id pub-id-type="pmid">20110278</pub-id></element-citation></ref><ref id="CR32"><label>32.</label><mixed-citation publication-type="other">Gamaarachchi, H., Parasemwaran, S. &#x00026; Smith, M. Datasets and experiment data of long read alignment using partitioned reference indexes. <italic>figshare</italic>, 10.6084/m9.figshare.6964805.v1 (2018).</mixed-citation></ref></ref-list></back></article>