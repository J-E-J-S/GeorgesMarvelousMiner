<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?><?DTDIdentifier.IdentifierType public?><?SourceDTD.DTDName A++V2.4.dtd?><?SourceDTD.Version 2.4?><?ConverterInfo.XSLTName springer2nlmx2.xsl?><?ConverterInfo.Version 1?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Genomics</journal-id><journal-id journal-id-type="iso-abbrev">BMC Genomics</journal-id><journal-title-group><journal-title>BMC Genomics</journal-title></journal-title-group><issn pub-type="epub">1471-2164</issn><publisher><publisher-name>BioMed Central</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">6551235</article-id><article-id pub-id-type="publisher-id">5701</article-id><article-id pub-id-type="doi">10.1186/s12864-019-5701-6</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Novel algorithms for LDD motif search</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Xiao</surname><given-names>Peng</given-names></name><address><email>peng.xiao@uconn.edu</email></address><xref ref-type="aff" rid="Aff1">1</xref></contrib><contrib contrib-type="author"><name><surname>Schiller</surname><given-names>Martin</given-names></name><address><email>martin.schiller@unlv.edu</email></address><xref ref-type="aff" rid="Aff2">2</xref></contrib><contrib contrib-type="author" corresp="yes"><name><surname>Rajasekaran</surname><given-names>Sanguthevar</given-names></name><address><email>rajasek@engr.uconn.edu</email></address><xref ref-type="aff" rid="Aff1">1</xref></contrib><aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 0860 4915</institution-id><institution-id institution-id-type="GRID">grid.63054.34</institution-id><institution>Department of Computer Science and Engineering, University of Connecticut, </institution></institution-wrap>371 Fairfield Road, Storrs, 06269 CT USA </aff><aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 0806 6926</institution-id><institution-id institution-id-type="GRID">grid.272362.0</institution-id><institution>School of Life Sciences, University of Nevada, </institution></institution-wrap>Las Vegas, NV USA </aff></contrib-group><pub-date pub-type="epub"><day>6</day><month>6</month><year>2019</year></pub-date><pub-date pub-type="pmc-release"><day>6</day><month>6</month><year>2019</year></pub-date><pub-date pub-type="collection"><year>2019</year></pub-date><volume>20</volume><issue>Suppl 5</issue><issue-sponsor>Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. The articles have undergone the journal's standard peer review process for supplements. The Supplement Editors declare that they have no competing interests.</issue-sponsor><elocation-id>424</elocation-id><permissions><copyright-statement>&#x000a9; The Author(s) 2019</copyright-statement><license license-type="OpenAccess"><license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p></license></permissions><abstract id="Abs1"><sec><title>Background</title><p>Motifs are crucial patterns that have numerous applications including the identification of transcription factors and their binding sites, composite regulatory patterns, similarity between families of proteins, etc. Several motif models have been proposed in the literature. The (<italic>l,d</italic>)-motif model is one of these that has been studied widely. However, this model will sometimes report too many spurious motifs than expected. We interpret a motif as a biologically significant entity that is evolutionarily preserved within some distance. It may be highly improbable that the motif undergoes the same number of changes in each of the species. To address this issue, in this paper, we introduce a new model which is more general than (<italic>l,d</italic>)-motif model. This model is called (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)-motif model (LDDMS) and is NP-hard as well. We present three elegant as well as efficient algorithms to solve the LDDMS problem, i.e., LDDMS1, LDDMS2 and LDDMS3. They are all exact algorithms.</p></sec><sec><title>Results</title><p>We did both theoretical analyses and empirical tests on these algorithms. Theoretical analyses demonstrate that our algorithms have less computational cost than the pattern driven approach. Empirical results on both simulated datasets and real datasets show that each of the three algorithms has some advantages on some (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>) instances.</p></sec><sec><title>Conclusions</title><p>We proposed LDDMS model which is more practically relevant. We also proposed three exact efficient algorithms to solve the problem. Besides, our algorithms can be nicely parallelized. We believe that the idea in this new model can also be extended to other motif search problems such as Edit-distance-based Motif Search (EMS) and Simple Motif Search (SMS).</p></sec></abstract><kwd-group xml:lang="en"><title>Keywords</title><kwd>Motif search</kwd><kwd>Radix sort</kwd><kwd>Neighborhood tree</kwd></kwd-group><conference xlink:href="https://iccabs.engr.uconn.edu/2017/"><conf-name>7th IEEE International Conference on Computational Advances in Bio and Medical Sciences (ICCABS 2017)</conf-name><conf-loc>Orlando, FL, USA</conf-loc><conf-date>19-21 October 2017</conf-date></conference><custom-meta-group><custom-meta><meta-name>issue-copyright-statement</meta-name><meta-value>&#x000a9; The Author(s) 2019</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="Sec1"><title>Background</title><p>Motif search has many applications in solving some crucial biological problems. For example, finding DNA motifs is very important for the determination of open reading frames, identification of gene promoter elements, location of RNA degradation signals, and the identification of alternative splicing sites [<xref ref-type="bibr" rid="CR1">1</xref>, <xref ref-type="bibr" rid="CR2">2</xref>]. For more than 15 years, motif search has stimulated a lot of interest from researchers in different areas.</p><p>There are many models of motif search. One popular model that has been studied extensively is the (<italic>l,d</italic>)-motif model. The corresponding motif search problem is called LDMS. The input for the LDMS problem consists of <italic>n</italic> input sequences each of length <italic>m</italic>, and two integers <italic>l</italic> and <italic>d</italic>. The task is to find all the strings (also called (<italic>l,d</italic>)-motifs) of length <italic>l</italic> each that occur in each of the input sequences within a hamming distance of <italic>d</italic>. The LDMS problem is known to be NP-hard [<xref ref-type="bibr" rid="CR3">3</xref>, <xref ref-type="bibr" rid="CR4">4</xref>].</p><p>Motifs can be thought of as evolutionarily preserved biological information. This information might have undergone different changes in different species. The (<italic>l,d</italic>)-motif model captures this possibility by requiring that the motif occur within a hamming distance of <italic>d</italic> in <bold>each</bold> sequence. However, this requirement may be more stringent than needed. When some biological information undergoes changes (e.g., mutations) in various species, the amount of change may not be the same across all the species. Some might have undergone more changes than the others. If we think of <italic>d</italic> as an upper bound on the amount of change, then it is conceivable (and very likely) that some of the species have undergone less changes. As a result, the (<italic>l,d</italic>)-motif model is likely to admit many spurious strings as motifs. These strings might occur by random chance and get qualified as motifs. Because of this, the LDMS algorithms might take longer time than actually needed. To rectify these shortcomings, in this paper we propose a new model of motifs. This model is called (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)-model. The corresponding motif search problem is called the LDDMS problem and defined next.</p><sec id="d29e385"><title><bold>Definition 1</bold></title><p>The input for the LDDMS problem has <italic>n</italic> biological sequences each of length <italic>m</italic> and three integers <italic>l,d</italic><sub>1</sub>, and <italic>d</italic><sub>2</sub>. The problem is to find all the strings <italic>M</italic> of length <italic>l</italic> that have the following two properties: 1) <italic>M</italic> should occur in each of the <italic>n</italic> input strings within a hamming distance of <italic>d</italic><sub>1</sub>. This requirement is referred to as the (<italic>l,d</italic><sub>1</sub>)-condition; and 2) <italic>M</italic> should occur in at least one of the <italic>n</italic> input strings within a hamming distance of <italic>d</italic><sub>2</sub>. This requirement is referred to as the (<italic>l,d</italic><sub>2</sub>)-condition.</p></sec><sec id="Sec2"><title>Validity of the (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)-motif model</title><p>In this section we demonstrate the validity of the (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)-motif model with a simple random model for mutations. Assume that the species under consideration have the same origin. Let <italic>M</italic> be an original motif of length <italic>l</italic>. Consider a random model where the number of mutations occurring in the species is uniformly distributed in the range <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\left [ 0,\frac {l}{2}\right ]$\end{document}</tex-math><mml:math id="M2"><mml:mfenced close="]" open="[" separators=""><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math><inline-graphic xlink:href="12864_2019_5701_Article_IEq1.gif"/></alternatives></inline-formula>. Let <italic>n</italic> be the number of species and let the number of mutations that have occurred in these species be <italic>X</italic><sub>1</sub>,<italic>X</italic><sub>2</sub>,&#x02026;,<italic>X</italic><sub><italic>n</italic></sub>, respectively and let <italic>Y</italic>= min{<italic>X</italic><sub>1</sub>,<italic>X</italic><sub>2</sub>,&#x02026;,<italic>X</italic><sub><italic>n</italic></sub>} and <italic>Z</italic>= max{<italic>X</italic><sub>1</sub>,<italic>X</italic><sub>2</sub>,&#x02026;,<italic>X</italic><sub><italic>n</italic></sub>}. It is easy to show that: 
<disp-formula id="Equa"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} E[Y] = \sum\limits_{k=1}^{l/2} k \frac{(l/2-k+1)^{n} - (l/2-k)^{n}}{(l/2+1)^{n}} \end{array} $$ \end{document}</tex-math><mml:math id="M4"><mml:mtable class="align" columnalign="left"><mml:mtr><mml:mtd class="align-1"><mml:mi>E</mml:mi><mml:mo>[</mml:mo><mml:mi>Y</mml:mi><mml:mo>]</mml:mo><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:munderover><mml:mi>k</mml:mi><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12864_2019_5701_Article_Equa.gif" position="anchor"/></alternatives></disp-formula></p><p>
<disp-formula id="Equb"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} E[Z] = \frac{1}{(l/2+1)^{n}} \sum\limits_{k=1}^{l/2}[(k+1)^{n}-k^{n}] \end{array} $$ \end{document}</tex-math><mml:math id="M6"><mml:mtable class="align" columnalign="left"><mml:mtr><mml:mtd class="align-1"><mml:mi>E</mml:mi><mml:mo>[</mml:mo><mml:mi>Z</mml:mi><mml:mo>]</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:munderover><mml:mo>[</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mo>]</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12864_2019_5701_Article_Equb.gif" position="anchor"/></alternatives></disp-formula>
</p><p>Thus the difference between <italic>Y</italic> and <italic>Z</italic> could be quite large! As an example consider an input of 20 sequences, each of length 600 and let <italic>l</italic>=10. Assume that the number of mutations <italic>d</italic> is uniformly random in the range [0,5]. If we set <italic>d</italic><sub>2</sub>=1, the probability that there exists at least one DNA sequence such that the motif occurs with a hamming distance of at most <italic>d</italic><sub>2</sub> is: 
<disp-formula id="Equc"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} p = 1 - {\left(\frac{4}{6}\right)}^{20} \approx 0.9997 \end{array} $$ \end{document}</tex-math><mml:math id="M8"><mml:mtable class="align" columnalign="left"><mml:mtr><mml:mtd class="align-1"><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mfrac><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>6</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>20</mml:mn></mml:mrow></mml:msup><mml:mo>&#x02248;</mml:mo><mml:mn>0.9997</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12864_2019_5701_Article_Equc.gif" position="anchor"/></alternatives></disp-formula></p><p>When <italic>n</italic> is larger than 20, this probability will become even higher. Therefore, it is quite reasonable to add the (<italic>l,d</italic><sub>2</sub>)-condition into the LDMS model.</p><p>It is easy to see that if <inline-formula id="IEq2"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$d_{2} \geqslant d_{1}$\end{document}</tex-math><mml:math id="M10"><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12864_2019_5701_Article_IEq2.gif"/></alternatives></inline-formula>, then the (<italic>l,d</italic><sub>2</sub>)-condition becomes trivial and the LDDMS problem will become the standard LDMS problem. Thus, the LDMS problem is a special case of the LDDMS problem. If <italic>d</italic><sub>2</sub>=0, it means that we want to look for a motif that appears exactly in at least one of the input sequences. In the rest of this paper we assume that <italic>d</italic><sub>2</sub>&#x0003c;<italic>d</italic><sub>1</sub>.</p></sec><sec id="Sec3"><title>Related work</title><p>(<italic>l,d</italic>) motif search is also referred to as Planted Motif Search (PMS) problem in some literature. Since (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>) motif search is closely related to PMS and we will use a PMS solver in one of the LDDMS algorithms, it is necessary to discuss some of the latest PMS algorithms.</p><p>In 2012, Yu, et al., proposed PairMotif to solve PMS problems [<xref ref-type="bibr" rid="CR5">5</xref>]. They reduced the size of candidate motifs and scanned <italic>l</italic>-mers by selecting pairs of <italic>l</italic>-mers from different input sequences and then generate the common neighbors. The authors tested PairMotif algorithm on simulated data as well as on five real data sets from [<xref ref-type="bibr" rid="CR6">6</xref>], which are preproinsulin, DHFR, c-fos, metallothionein and Yeast ECB. It can solve the weak instance (27, 9) within 10 hours. They also showed that PairMotif is more stable in solving PMS problem in longer input sequences [<xref ref-type="bibr" rid="CR5">5</xref>].</p><p>Sometimes, biologists may also be interested in motifs that occur in a fraction of the input strings. The problem of identifying such motifs is known as quorum Planted Motif Search (qPMS). In this case, in addition to <italic>l</italic> and <italic>d</italic> and <italic>n</italic> strings there is an extra input parameter <italic>q</italic>. The problem is to identify all the (<italic>l,d</italic>,<italic>q</italic>)-motifs, that is, all the (<italic>l,d</italic>)-motifs that occur in at least <italic>q</italic>% of the input strings. In 2014, Tanaka proposed TraverStringRef in [<xref ref-type="bibr" rid="CR7">7</xref>]. This algorithm is based on the PMS8 algorithm of Nicolae and Rajasekaran [<xref ref-type="bibr" rid="CR8">8</xref>]. This is the first algorithm that solved the challenging DNA instance with (<italic>l,d</italic>,<italic>q</italic>)=(25,10,20) in a reasonable amount of time.</p><p>In 2015, Nicolae and Rajasekaran proposed qPMS9 [<xref ref-type="bibr" rid="CR9">9</xref>]. It can solve challenging instances up to (25,10) using a single core machine and up to (30,13) using a 48-core machine. The algorithm is based on PMS8 proposed by the same authors [<xref ref-type="bibr" rid="CR8">8</xref>], but it added quorum support and also included better pruning techniques to significantly reduce the size of the search space.</p><p>In 2016, Xiao, Pal and Rajasekaran proposed qPMS10 [<xref ref-type="bibr" rid="CR3">3</xref>, <xref ref-type="bibr" rid="CR4">4</xref>]. qPMS10 is a randomized algorithm based on the idea of random sampling. It will first utilize any existing PMS solver on a subset of the input. Then the candidate motifs are filtered to get the correct motifs for the original problem. Probability analysis shows that with high probability, the result is correct. Experimental result shows that this algorithm is competitive especially when the dataset is large.</p><p>Not only mutations, but also insertions and deletions are important as they may also play critical roles in divergence of biological sequences [<xref ref-type="bibr" rid="CR10">10</xref>, <xref ref-type="bibr" rid="CR11">11</xref>]. In this case, edit distance instead of hamming distance should be considered [<xref ref-type="bibr" rid="CR12">12</xref>, <xref ref-type="bibr" rid="CR13">13</xref>]. This corresponding problem is modeled as <italic>Edit-distance-based Motif Search (EMS)</italic> problem. There are also some works in the literature on EMS (see e.g., [<xref ref-type="bibr" rid="CR1">1</xref>, <xref ref-type="bibr" rid="CR12">12</xref>&#x02013;<xref ref-type="bibr" rid="CR15">15</xref>], and so on).</p><p>However, as far as the authors know, no such generalizations of PMS model exist in the published literature. Therefore, we propose LDDMS model and the corresponding algorithms.</p></sec></sec><sec id="Sec4"><title>Methods</title><p>Since the LDMS problem is NP-hard, the LDDMS problem is also NP-hard. All the known exact algorithms for solving the LDMS problem take time that is exponential in some of the underlying parameters. In this paper, we present three efficient algorithms for solving the LDDMS problem. These algorithms are referred to as LDDMS1, LDDMS2 and LDDMS3. Time complexities of these three algorithms are analysed. Experimental results on simulated dataset and real datasets both demonstrate that our algorithms are efficient.</p><sec id="Sec5"><title>Description of LDDMS algorithms</title><p>For any <italic>l</italic>-mer <italic>u</italic> we define its <italic>d</italic>-friendhood as the set of <italic>l</italic>-mers <italic>v</italic> whose hamming distance is exactly <italic>d</italic> from <italic>u</italic>; define its <italic>d</italic>-neighborhood as the set of <italic>l</italic>-mers <italic>v</italic> whose hamming distance is at most <italic>d</italic> from <italic>u</italic>.</p><p>For all the LDDMS algorithms, the input is a database <italic>S</italic> containing <italic>n</italic> sequences, each of length <italic>m</italic>, and integers <italic>l</italic>, <italic>d</italic><sub>1</sub> and <italic>d</italic><sub>2</sub>; the output is all the strings of length <italic>l</italic> that meet both (<italic>l,d</italic><sub>1</sub>)-condition and (<italic>l,d</italic><sub>2</sub>)-condition.</p><p>A straight-forward solution is the pattern driven approach. If <italic>&#x003a3;</italic> is the alphabet under concern, there are |<italic>&#x003a3;</italic>|<sup><italic>l</italic></sup> possible <italic>l</italic>-mers. For every such <italic>l</italic>-mer, check if it meets both the (<italic>l,d</italic><sub>1</sub>)-condition and the (<italic>l,d</italic><sub>2</sub>)-condition. If so, output this <italic>l</italic>-mer. Obviously, this algorithm takes too much time.</p><p>In addition to pattern driven approaches, we also have sample driven approaches. We could employ the following two step algorithm: 1) First find all the motifs that satisfy the (<italic>l,d</italic><sub>1</sub>)-condition. This can be done using any of the LDMS algorithms. Let <italic>C</italic><sub>1</sub> be the set of these motifs; and 2) For every motif <italic>x</italic>&#x02208;<italic>C</italic><sub>1</sub>, check if <italic>x</italic> satisfies the (<italic>l,d</italic><sub>2</sub>)-condition and if so output <italic>x</italic>. We call this algorithm LDDMS1. Since qPMS9 is currently the most efficient LDMS algorithm [<xref ref-type="bibr" rid="CR9">9</xref>], we will take advantage of it in LDDMS1 (See Algorithm 1).</p><p>Equivalently, we can also find (<italic>l,d</italic><sub>2</sub>)-motifs in the first step, and then for every such motif check if it satisfies the (<italic>l,d</italic><sub>1</sub>)-condition. We refer to this algorithm as LDDMS2 (See Algorithm 2).</p><p>Note that each valid motif has at least one <italic>d</italic><sub>2</sub>-neighbor in at least one of the input sequences. We generate <italic>n</italic>(<italic>m</italic>&#x02212;<italic>l</italic>+1)<italic>l</italic>-mers from each of the input sequences. <italic>d</italic><sub>2</sub>-neighborhood of an <italic>l</italic>-mer <italic>u</italic> can be found by constructing the neighborhood tree. With <italic>u</italic> being the root and the height of the tree being <italic>d</italic><sub>2</sub>, the level of a node is the hamming distance between <italic>u</italic> and this node. All the nodes of this tree, including the root and the leaves, will constitute the <italic>d</italic><sub>2</sub>-neighborhood of <italic>u</italic>. In Step 3 of LDDMS2, we can employ radix sort and eliminate duplicates. In Step 4 the output <italic>O</italic><sub>2</sub> of valid motifs found will be in sorted order.</p><p>
<graphic position="anchor" xlink:href="12864_2019_5701_Figa_HTML" id="MO1"/>
</p><p>
<graphic position="anchor" xlink:href="12864_2019_5701_Figb_HTML" id="MO2"/>
</p><p>If <italic>d</italic><sub>2</sub> is very small (for example, <italic>d</italic><sub>2</sub> = 0 or 1), we can expect LDDMS2 to run faster than LDDMS1. This is because the <italic>d</italic><sub>2</sub>-neighborhhod for any <italic>l</italic>-mer will be small. However, when <italic>d</italic><sub>2</sub> is large, the neighborhood tree will be large and so will be the number of candidate motifs. Therefore, LDDMS2 takes much more time and memory when <italic>d</italic><sub>2</sub> is large. To save time, one idea is to check the candidate motifs concurrently while constructing the neighborhood tree. During the checking process, some pruning conditions can be developed such that once certain conditions hold, a node is not explored deeper. The stronger the pruning condition is, the faster the algorithm will be. Inspired by similar pruning ideas proposed for the LDMS model [<xref ref-type="bibr" rid="CR16">16</xref>], we develop LDDMS3 (See Algorithm 3).</p><sec id="d29e1264"><title><bold>Definition 2</bold></title><p>Given an <italic>l</italic>-mer <italic>u</italic> from Sequence <italic>i</italic> (<italic>i</italic>&#x02208; [1,<italic>n</italic>]), construct its <italic>d</italic><sub>2</sub>-neighborhood tree. Let <italic>x</italic> be any node in this tree, denote <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>q</italic>) as the smallest hamming distance between <italic>x</italic> and any <italic>l</italic>-mer out of Sequence <italic>q</italic>. Denote <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>) to be the maximum of <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>q</italic>) where <italic>q</italic>=1,2,...,<italic>n</italic> and <italic>q</italic>&#x02260;<italic>i</italic>. 
<disp-formula id="Equd"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\delta(x, i, I) = \max\limits_{q = 1, q \neq i}^{n} \delta(x, i, q) = \max \limits_{q = 1, q \neq i}^{n} \min \limits_{v \triangleleft_{l} s_{q}} Hd(v, x) $$ \end{document}</tex-math><mml:math id="M12"><mml:mrow><mml:mi>&#x003b4;</mml:mi><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>max</mml:mo></mml:mrow><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>&#x02260;</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mi>&#x003b4;</mml:mi><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>max</mml:mo></mml:mrow><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>&#x02260;</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:munder><mml:mrow><mml:mo>min</mml:mo></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:msub><mml:mrow><mml:mi>&#x022b2;</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mtext mathvariant="italic">Hd</mml:mtext><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="12864_2019_5701_Article_Equd.gif" position="anchor"/></alternatives></disp-formula></p><p>
<graphic position="anchor" xlink:href="12864_2019_5701_Figc_HTML" id="MO3"/>
</p><p>If <italic>v</italic> is an <italic>l</italic>-mer in the sequence <italic>S</italic><sub><italic>q</italic></sub>, we denote it as: <italic>v</italic><italic>&#x022b2;</italic><sub><italic>l</italic></sub><italic>s</italic><sub><italic>q</italic></sub>. Also, <italic>Hd</italic>(<italic>v,x</italic>) is the hamming distance between <italic>v</italic> and <italic>x</italic>. By computing <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>), we have the following pruning conditions [<xref ref-type="bibr" rid="CR16">16</xref>].</p></sec><sec id="d29e1527"><title><bold>Theorem 1</bold></title><p>Traverse the <italic>d</italic><sub>2</sub>-neighborhood tree of <italic>u</italic> in a depth-first manner and compute <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>) where <italic>x</italic> is a node in the tree, <italic>h</italic> is the level of <italic>x</italic> (root is at level 0); 
<list list-type="order"><list-item><p>If <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>)&#x02264;<italic>d</italic><sub>1</sub>, output <italic>x</italic>;</p></list-item><list-item><p>If <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>)&#x02212;<italic>d</italic><sub>1</sub>&#x0003e;<italic>d</italic><sub>2</sub>&#x02212;<italic>h</italic>, prune all the descendants from <italic>x</italic>;</p></list-item><list-item><p>If <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>)&#x02212;<italic>d</italic><sub>1</sub>=<italic>d</italic><sub>2</sub>&#x02212;<italic>h</italic>, consider only <italic>x</italic>&#x02032; such that <italic>x</italic>&#x02032; is a child of <italic>x</italic> and <italic>&#x003b4;</italic>(<italic>x</italic>&#x02032;,<italic>i,I</italic>)=<italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>)&#x02212;1;</p></list-item><list-item><p>If <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>)&#x02212;<italic>d</italic><sub>1</sub>=<italic>d</italic><sub>2</sub>&#x02212;<italic>h</italic>&#x02212;1, consider only <italic>x</italic>&#x02032; such that <italic>x</italic>&#x02032; is a child of <italic>x</italic> and <italic>&#x003b4;</italic>(<italic>x</italic>&#x02032;,<italic>i,I</italic>)&#x02264;<italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>).</p></list-item></list></p></sec></sec><sec id="Sec6"><title>Analysis of LDDMS algorithms</title><sec id="Sec7"><title>Candidate size and expected number of motifs</title><p>In this section, we estimate candidate sizes of LDDMS1 and LDDMS2, i.e., |<italic>C</italic><sub>1</sub>| and |<italic>C</italic><sub>2</sub>|, and also the expected number of motifs that would be found. Such estimation is useful in computing the time complexities of these two algorithms.</p><p>Recall that in the benchmark dataset all the characters are generated from i.i.d. and there are <italic>n</italic> sequences with length <italic>m</italic> each. Given an <italic>l</italic>-mer <italic>M</italic>, the number of <italic>l</italic>-mers that have a hamming distance of &#x02264;<italic>d</italic><sub>1</sub> from <italic>M</italic> is: 
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ N(\Sigma, l, d_{1}) = \sum\limits_{i=0}^{d_{1}} {{l}\choose{i}} (|\Sigma|-1)^{i}  $$ \end{document}</tex-math><mml:math id="M14"><mml:mi>N</mml:mi><mml:mo>(</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:mfenced close=")" open="(" separators=""><mml:mfrac linethickness="0"><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfrac></mml:mfenced><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:mo>|</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p><p>where <italic>&#x003a3;</italic> is the alphabet under concern.</p><p>The probability that a randomly chosen <italic>l</italic>-mer has a hamming distance of at most <italic>d</italic><sub>1</sub> from <italic>M</italic> is: 
<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ p_{1}=\frac{N(\Sigma, l, d_{1})}{|\Sigma|^{l}}  $$ \end{document}</tex-math><mml:math id="M16"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>N</mml:mi><mml:mo>(</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula></p><p>The probability that in a sequence of length <italic>m</italic>, there is at least one string <italic>u</italic> such that <italic>u</italic> and <italic>M</italic> are within a hamming distance of <italic>d</italic><sub>1</sub> is: 
<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ p_{2}= 1-(1-p_{1})^{m-l+1}  $$ \end{document}</tex-math><mml:math id="M18"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula></p><p>The probability that a randomly chosen <italic>l</italic>-mer occurs within a hamming distance of <italic>d</italic><sub>1</sub> in each of the <italic>n</italic> input sequences, each of length <italic>m</italic> is: 
<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ p_{3}= p_{2}^{n}\\  $$ \end{document}</tex-math><mml:math id="M20"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula></p><p>Therefore, the expected number of (<italic>l,d</italic><sub>1</sub>)-motifs is: 
<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ |C_{1}|= | \Sigma |^{l} p_{3}  $$ \end{document}</tex-math><mml:math id="M22"><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula></p><p>Similarly, the probability that a randomly chosen <italic>l</italic>-mer has a hamming distance of at most <italic>d</italic><sub>2</sub> from <italic>M</italic> is: 
<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ p_{4}= \frac{ {\sum\nolimits}_{i=0}^{d_{2}} {{l}\choose{i}} (|\Sigma|-1)^{i}}{| \Sigma |^{l}}  $$ \end{document}</tex-math><mml:math id="M24"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mfenced close=")" open="(" separators=""><mml:mfrac linethickness="0"><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfrac></mml:mfenced><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:mo>|</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula></p><p>The probability that in a sequence of length <italic>m</italic>, there is at least one string <italic>u</italic> that has a hamming distance of at most <italic>d</italic><sub>2</sub> from <italic>M</italic> is: 
<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ p_{5}= 1 - \left(1 - p_{4} \right)^{m - l + 1}  $$ \end{document}</tex-math><mml:math id="M26"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula></p><p>Therefore, the expected number of (<italic>l,d</italic><sub>2</sub>)-motifs is: 
<disp-formula id="Equ8"><label>8</label><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ |C_{2}|= | \Sigma |^{l} \left(1 - (1- p_{5})^{n}\right)  $$ \end{document}</tex-math><mml:math id="M28"><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msup><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ8.gif" position="anchor"/></alternatives></disp-formula></p><p>In all of the above assertions we have assumed that the <italic>l</italic>-mers of a sequence are independent. Clearly, this is incorrect. However, such analyses have proven useful in estimating the number of motifs in practice (see e.g., [<xref ref-type="bibr" rid="CR17">17</xref>]). Along these lines, let us look at the expected number of motifs that will be found, i.e., |<italic>O</italic><sub>1</sub>| or |<italic>O</italic><sub>2</sub>|. Let <italic>M</italic> be a random <italic>l</italic>-mer, <italic>A</italic><sub><italic>i</italic></sub> be the event that <italic>M</italic> has a neighbor that is within a hamming distance of <italic>d</italic><sub>2</sub> in exactly <italic>i</italic> of the input sequences. Similarly, let <italic>B</italic><sub><italic>j</italic></sub> be the event that <italic>M</italic> has a neighbor that is within a hamming distance of (<italic>d</italic><sub>2</sub>,<italic>d</italic><sub>1</sub>] in exactly <italic>j</italic> of the input sequences. It should be noted here that if <italic>M</italic> has a neighbor whose hamming distance is at most <italic>d</italic><sub>2</sub> in an input sequence, then it automatically will also have a neighbor that is within a hamming distance of <italic>d</italic><sub>1</sub> in such sequence since we assume <italic>d</italic><sub>2</sub>&#x0003c;<italic>d</italic><sub>1</sub>.</p><p>We want to know the probability that events <italic>A</italic><sub><italic>i</italic></sub> and <italic>B</italic><sub><italic>n</italic>&#x02212;<italic>i</italic></sub> both happen, which means in each of the <italic>n</italic> input sequences, there is an <italic>l</italic>-mer that is within a hamming distance of <italic>d</italic><sub>2</sub> from <italic>M</italic> and also, in each of the remaining <italic>n</italic>&#x02212;<italic>i</italic> input sequences, there will be an <italic>l</italic>-mer that is within a hamming distance of (<italic>d</italic><sub>2</sub>,<italic>d</italic><sub>1</sub>] from <italic>M</italic>.</p><p>Given an <italic>l</italic>-mer <italic>M</italic>, the probability that a random string <italic>u</italic> of length <italic>l</italic> has a hamming distance in the range of (<italic>d</italic><sub>2</sub>,<italic>d</italic><sub>1</sub>] from <italic>M</italic> is: 
<disp-formula id="Equ9"><label>9</label><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ p_{6} = \frac{{\sum\nolimits}_{i=d_{2}+1}^{d_{1}} {{l}\choose{i}} (|\Sigma|-1)^{i}}{| \Sigma |^{l}}  $$ \end{document}</tex-math><mml:math id="M30"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>6</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mfenced close=")" open="(" separators=""><mml:mfrac linethickness="0"><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfrac></mml:mfenced><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:mo>|</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ9.gif" position="anchor"/></alternatives></disp-formula></p><p>In one sequence, there are <italic>m</italic>&#x02212;<italic>l</italic>+1 such <italic>l</italic>-mers. The probability that in such a sequence, there is at least one <italic>l</italic>-mer that is within a hamming distance of <italic>d</italic><sub>1</sub> but no <italic>l</italic>-mer that is within a hamming distance of <italic>d</italic><sub>2</sub> from <italic>M</italic> is: 
<disp-formula id="Equ10"><label>10</label><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ p_{7} = \sum\limits_{k=1}^{m-l+1} {{m-l+1}\choose{k}} p_{6}^{k} (1-p_{4}-p_{6})^{(m-l+1-k)}  $$ \end{document}</tex-math><mml:math id="M32"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>7</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mfenced close=")" open="(" separators=""><mml:mfrac linethickness="0"><mml:mrow><mml:mi>m</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfrac></mml:mfenced><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>6</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>6</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ10.gif" position="anchor"/></alternatives></disp-formula></p><p>Therefore, the probability that a random <italic>l</italic>-mer out of such dataset meets both (<italic>l,d</italic><sub>1</sub>) and (<italic>l,d</italic><sub>2</sub>)-condition is: 
<disp-formula id="Equ11"><label>11</label><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ p_{8} = \sum\limits_{i=1}^{n} p(A_{i} \cap B_{n-i}) = \sum\limits_{i=1}^{n} {{n}\choose{i}} p_{5}^{i} p_{7}^{(n-i)}  $$ \end{document}</tex-math><mml:math id="M34"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mi>p</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02229;</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mfenced close=")" open="(" separators=""><mml:mfrac linethickness="0"><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfrac></mml:mfenced><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>7</mml:mn></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msubsup></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ11.gif" position="anchor"/></alternatives></disp-formula></p><p>In conclusion, the expected number of spurious motifs we can find in the LDDMS model is: 
<disp-formula id="Equ12"><label>12</label><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ |O_{1}| = |O_{2}| = |O_{3}| = | \Sigma |^{l} p_{8}  $$ \end{document}</tex-math><mml:math id="M36"><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:msub></mml:math><graphic xlink:href="12864_2019_5701_Article_Equ12.gif" position="anchor"/></alternatives></disp-formula></p></sec><sec id="Sec8"><title>Time complexity of the algorithms</title><p>Note that all the three algorithms (LDDMS1, LDDMS2, and LDDMS3) can be nicely parallelized. For LDDMS1, there are parallel versions of LDMS solvers, such as PMS9. For every candidate motif, the checking process is independent and can also be parallelized. For LDDMS2 and LDDMS3, we need to generate the neighnorhood tree for <italic>n</italic>(<italic>m</italic>&#x02212;<italic>l</italic>+1)<italic>l</italic>-mers out of the input sequences. There are <italic>n</italic>(<italic>m</italic>&#x02212;<italic>l</italic>+1) independent subproblems and can be assigned to different processors. However, in this paper, we only implement these algorithms sequentially and analyze the time complexity of the sequential versions of these algorithms.</p><p>Given a candidate motif of length <italic>l</italic>, checking if it meets (<italic>l,d</italic><sub>1</sub>) and (<italic>l,d</italic><sub>2</sub>)-condition in an input of <italic>n</italic> sequences, each of length <italic>m</italic>, will take <italic>O</italic>((<italic>m</italic>&#x02212;<italic>l</italic>+1)<italic>nl</italic>)=<italic>O</italic>(<italic>m</italic><italic>nl</italic>) time. It is easy to see that the brute-force algorithm takes time <italic>O</italic>(|<italic>&#x003a3;</italic>|<sup><italic>l</italic></sup><italic>m</italic><italic>nl</italic>).</p><p>For LDDMS1, qPMS9 can be implemented in <italic>O</italic>(<italic>m</italic><sup><italic>k</italic></sup><italic>mnN</italic>(<italic>&#x003a3;</italic>,<italic>l,d</italic><sub>1</sub>)) time. <italic>N</italic>(<italic>&#x003a3;</italic>,<italic>l,d</italic><sub>1</sub>) has the same definition as in Eq. <xref rid="Equ1" ref-type="">1</xref>. <italic>k</italic> is a dynamic variable between 1 and <italic>n</italic>. We get the following:</p><sec id="d29e3031"><title><bold>Theorem 2</bold></title><p>The time complexity of LDDMS1 algorithm is 
<disp-formula id="Eque"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$T_{LDDMS1}=O(m^{k}mnN(\Sigma, l, d_{1})+|C_{1}|mnl)$$ \end{document}</tex-math><mml:math id="M38"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">LDDMS</mml:mtext><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mtext mathvariant="italic">mnN</mml:mtext><mml:mo>(</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mtext mathvariant="italic">mnl</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="12864_2019_5701_Article_Eque.gif" position="anchor"/></alternatives></disp-formula> where |<italic>C</italic><sub>1</sub>| is the candidate size of (<italic>l,d</italic><sub>1</sub>)-motif. An expected number can be obtained from Eq. <xref rid="Equ5" ref-type=""><italic>5</italic></xref>.</p><p>For LDDMS2, in Step 1 and Step 2, generating the neighborhoods from all <italic>l</italic>-mers out of each of the input sequences will take time <italic>O</italic>((<italic>m</italic>&#x02212;<italic>l</italic>+1)<italic>nN</italic>(<italic>&#x003a3;</italic>,<italic>l,d</italic><sub>2</sub>)). In Step 3, radix sort and removing the duplicates will take time <italic>O</italic>((<italic>m</italic>&#x02212;<italic>l</italic>+1)<italic>nl</italic><italic>N</italic>(<italic>&#x003a3;</italic>,<italic>l,d</italic><sub>2</sub>)). Thus we arrive at:</p></sec><sec id="d29e3170"><title><bold>Theorem 3</bold></title><p>LDDMS2 can be implemented in time 
<disp-formula id="Equf"><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \begin{aligned} T_{LDDMS2}=O \left((m - l + 1)nl N(\Sigma, l, d_{2}) \right) + O(|C_{2}| mnl) \\ = O(mnl N(\Sigma, l, d_{2})+|C_{2}|mnl) \end{aligned} $$ \end{document}</tex-math><mml:math id="M40"><mml:mrow><mml:mspace width="-12.0pt"/><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">LDDMS</mml:mtext><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mtext mathvariant="italic">nlN</mml:mtext><mml:mo>(</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mtext mathvariant="italic">mnl</mml:mtext><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">mnlN</mml:mtext><mml:mo>(</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mtext mathvariant="italic">mnl</mml:mtext><mml:mo>)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12864_2019_5701_Article_Equf.gif" position="anchor"/></alternatives></disp-formula> where |<italic>C</italic><sub>2</sub>| is the candidate size of (<italic>l,d</italic><sub>2</sub>)-motif. An expected number is given in Eq. <xref rid="Equ8" ref-type=""><italic>8</italic></xref>.</p><p>The following lemma from [<xref ref-type="bibr" rid="CR16">16</xref>] is useful in computing the time complexity of LDDMS3.</p></sec><sec id="d29e3328"><title><bold>Lemma 1</bold></title><p>For a node <italic>x</italic> in the neighborhood tree, <italic>&#x003b4;</italic>(<italic>x,i</italic>,<italic>I</italic>) can be updated in <italic>O</italic>(<italic>mn</italic>) time.</p></sec><sec id="d29e3353"><title><bold>Theorem 4</bold></title><p>LDDMS3 can be implemented in time 
<disp-formula id="Equg"><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$T_{LDDMS3} = O\left(n^{2}m^{2} N\left(\Sigma, l, d_{2}\right)\right) $$ \end{document}</tex-math><mml:math id="M42"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">LDDMS</mml:mtext><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>N</mml:mi><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>&#x003a3;</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:math><graphic xlink:href="12864_2019_5701_Article_Equg.gif" position="anchor"/></alternatives></disp-formula></p><p>Note this is only the worst-case time complexity and <italic>d</italic><sub>1</sub> does not appear in this expression. The actual run time could be much less because a lot of branches can be &#x0201c;pruned&#x0201d;.</p></sec></sec></sec></sec><sec id="Sec9"><title>Results and discussion</title><p>LDDMS1, LDDMS2 and LDDMS3 are tested on synthetic datasets as well as real datasets. We evaluated our algorithms on a Dell Precisions Workstation T7910 running RHEL 7.0 on two sockets each containing 8 Dual Intel Xeon Processors E5-2667 (8C HT, 20MB Cache, 3.2GHz) and 256GB RAM.</p><sec id="Sec10"><title>Synthetic datasets</title><p>Following the tradition, we employ combinations of (<italic>l,d</italic><sub>1</sub>) that are challenging [<xref ref-type="bibr" rid="CR3">3</xref>]. We vary <italic>d</italic><sub>2</sub> from 0 to &#x0230a;<italic>d</italic><sub>1</sub>/2&#x0230b;. The challenging instances of <italic>n</italic>=20,<italic>m</italic>=600 for DNA sequences and the values of <italic>d</italic><sub>2</sub> for carrying out the test are listed in Table&#x000a0;<xref rid="Tab1" ref-type="table">1</xref>.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Challenging instances and value of <italic>d</italic><sub>2</sub> for test (<italic>n</italic>=20,<italic>m</italic>=600)</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">
<italic>l</italic>
</th><th align="left">
<italic>d</italic>
<sub>1</sub>
</th><th align="left">
<italic>d</italic>
<sub>2</sub>
</th></tr></thead><tbody><tr><td align="left">7</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">8</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">9</td><td align="left">2</td><td align="left">[0,1]</td></tr><tr><td align="left">10</td><td align="left">2</td><td align="left">[0,1]</td></tr><tr><td align="left">11</td><td align="left">3</td><td align="left">[0,1]</td></tr><tr><td align="left">12</td><td align="left">3</td><td align="left">[0,1]</td></tr><tr><td align="left">13</td><td align="left">4</td><td align="left">[0,2]</td></tr><tr><td align="left">14</td><td align="left">4</td><td align="left">[0,2]</td></tr><tr><td align="left">15</td><td align="left">5</td><td align="left">[0,2]</td></tr><tr><td align="left">16</td><td align="left">5</td><td align="left">[0,2]</td></tr><tr><td align="left">17</td><td align="left">6</td><td align="left">[0,3]</td></tr><tr><td align="left">18</td><td align="left">6</td><td align="left">[0,3]</td></tr><tr><td align="left">19</td><td align="left">7</td><td align="left">[0,3]</td></tr></tbody></table></table-wrap></p><p>The challenging instances correspond to a small number of spurious motifs. This will make the candidate size in LDDMS1 very small and hence the time spent in Step 2 in LDDMS1 is trivial. To avoid such problems, we slightly change the way we plant the motifs. We will randomly generate two <italic>l</italic>-mers, <italic>M</italic><sub>1</sub> and <italic>M</italic><sub>2</sub>. The hamming distance of <italic>M</italic><sub>1</sub> and <italic>M</italic><sub>2</sub> is <italic>q</italic>. Then we insert <italic>M</italic><sub>1</sub> into each of the first &#x02308;<italic>n</italic>/2&#x02309; input sequences and <italic>M</italic><sub>2</sub> into each of the rest &#x0230a;<italic>n</italic>/2&#x0230b; input sequences. A detailed algorithm for generating the test cases is given in Algorithm 4.</p><p>
<graphic position="anchor" xlink:href="12864_2019_5701_Figd_HTML" id="MO4"/>
</p><p>In this way, the common neighbors that are within <italic>d</italic><sub>2</sub> hamming distance of <italic>M</italic><sub>1</sub> and <italic>M</italic><sub>2</sub> are (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)-motifs we plant. Generally, when <italic>q</italic> is small, there will be more common neighbors between <italic>M</italic><sub>1</sub> and <italic>M</italic><sub>2</sub>. Conversely, when <italic>q</italic> is large, there are fewer common neighbors between <italic>M</italic><sub>1</sub> and <italic>M</italic><sub>2</sub>. By varying <italic>q</italic>, we can control the output motif size. There is a theory proposed in [<xref ref-type="bibr" rid="CR8">8</xref>] which proves to be useful here.</p><sec id="d29e3758"><title><bold>Theorem 5</bold></title><p>Two <italic>l</italic>-mers <italic>a</italic> and <italic>b</italic> have a common neighbor <italic>M</italic> such that <italic>Hd</italic>(<italic>a,M</italic>)&#x02264;<italic>d</italic><sub><italic>a</italic></sub> and <italic>Hd</italic>(<italic>b,M</italic>)&#x02264;<italic>d</italic><sub><italic>b</italic></sub> if and only if <italic>Hd</italic>(<italic>a,b</italic>)&#x02264;<italic>d</italic><sub><italic>a</italic></sub>+<italic>d</italic><sub><italic>b</italic></sub>.</p><p>Applying the above theorem, <italic>q</italic> has to be at a distance of at most 2<italic>d</italic><sub>2</sub> for <italic>M</italic><sub>1</sub> and <italic>M</italic><sub>2</sub> to have common neighbors that are within a <italic>d</italic><sub>2</sub> hamming distance. When <italic>d</italic><sub>2</sub>=0, we set <italic>q</italic>=0, then there will be at least <italic>N</italic>(<italic>&#x003a3;</italic>,<italic>l,d</italic><sub>2</sub>)(<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)-motifs that can be found. When <italic>d</italic><sub>2</sub>&#x02260;0,<italic>q</italic>=2<italic>d</italic><sub>2</sub>, there will be at least <inline-formula id="IEq3"><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}${{2d_{2}}\choose {d_{2}}} (l, d_{1}, d_{2})$\end{document}</tex-math><mml:math id="M44"><mml:mfenced close=")" open="(" separators=""><mml:mfrac linethickness="0"><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mfenced><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12864_2019_5701_Article_IEq3.gif"/></alternatives></inline-formula>-motifs that can be found. However, the number of planted (<italic>l,d</italic><sub>1</sub>)-motifs, i.e., common neighbors that are within a <italic>d</italic><sub>1</sub> hamming distance between both <italic>M</italic><sub>1</sub> and <italic>M</italic><sub>2</sub>, is much larger.</p><p>We have tested our algorithms on challenging instances of (<italic>l,d</italic><sub>1</sub>) from (7,1) upto (19,7), where <italic>d</italic><sub>2</sub> varies from 0 to &#x0230a;<italic>d</italic><sub>1</sub>/2&#x0230b;. Tables&#x000a0;<xref rid="Tab2" ref-type="table">2</xref>, <xref rid="Tab3" ref-type="table">3</xref> and <xref rid="Tab4" ref-type="table">4</xref> show the running times of LDDMS1, LDDMS2 and LDDMS3 on different (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>) values. For small instances such as (<italic>l,d</italic><sub>1</sub>) = (7,1), (8,1), (9,2), (10,2), LDDMS1 runs faster than LDDMS2 and LDDMS3. This is because qPMS9 is fast and there are only a few (<italic>l,d</italic><sub>1</sub>)-motifs to check. However, for moderate and relatively large instances, a small value of <italic>d</italic><sub>2</sub> will make LDDMS2 run much faster than LDDMS1. For example, for (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)=(17,6,1), LDDMS1 takes 29.36 minutes while LDDMS2 only takes 9.19 minutes to solve. However, for large values of <italic>d</italic><sub>2</sub>, LDDMS2 is slow. Compared to LDDMS2, LDDMS3 performs much better for large instances although it will take more time when <italic>d</italic><sub>2</sub> is small. For example, it can solve instances which LDDMS2 cannot solve, such as (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)=(18,6,3),(19,7,3).
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Running time of LDDMS1</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">
<italic>d</italic>
<sub>2</sub>
</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th></tr></thead><tbody><tr><td align="left">(<italic>l,d</italic><sub>1</sub>)</td><td align="left"/><td align="left"/><td align="left"/><td align="left"/></tr><tr><td align="left">(7,1)</td><td align="left">0.24 s</td><td align="left">NA</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(8,1)</td><td align="left">0.19 s</td><td align="left">NA</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(9,2)</td><td align="left">0.44 s</td><td align="left">0.42 s</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(10,2)</td><td align="left">0.34 s</td><td align="left">0.31 s</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(11,3)</td><td align="left">1.91 s</td><td align="left">1.24 s</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(12,3)</td><td align="left">1.83 s</td><td align="left">0.81 s</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(13,4)</td><td align="left">20.19 s</td><td align="left">9.75 s</td><td align="left">7.36 s</td><td align="left">NA</td></tr><tr><td align="left">(14,4)</td><td align="left">23.03 s</td><td align="left">8.11 s</td><td align="left">5.18 s</td><td align="left">NA</td></tr><tr><td align="left">(15,5)</td><td align="left">4.75 m</td><td align="left">2.51 m</td><td align="left">1.51 m</td><td align="left">NA</td></tr><tr><td align="left">(16,5)</td><td align="left">6.18 m</td><td align="left">2.32 m</td><td align="left">1.17 m</td><td align="left">NA</td></tr><tr><td align="left">(17,6)</td><td align="left">1.12 h</td><td align="left">29.36 m</td><td align="left">20.63 m</td><td align="left">12.02 m</td></tr><tr><td align="left">(18,6)</td><td align="left">1.57 h</td><td align="left">36.55 m</td><td align="left">24.51 m</td><td align="left">13.44 m</td></tr><tr><td align="left">(19,7)</td><td align="left">10.68 h</td><td align="left">7.74 h</td><td align="left">6.13 h</td><td align="left">4.02 h</td></tr></tbody></table></table-wrap>
<table-wrap id="Tab3"><label>Table 3</label><caption><p>Running time of LDDMS2</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">
<italic>d</italic>
<sub>2</sub>
</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th></tr></thead><tbody><tr><td align="left">(<italic>l,d</italic><sub>1</sub>)</td><td align="left"/><td align="left"/><td align="left"/><td align="left"/></tr><tr><td align="left">(7,1)</td><td align="left">2.76 s</td><td align="left">NA</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(8,1)</td><td align="left">5.26 s</td><td align="left">NA</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(9,2)</td><td align="left">5.34 s</td><td align="left">1.45 m</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(10,2)</td><td align="left">7.86 s</td><td align="left">3.47 m</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(11,3)</td><td align="left">7.14 s</td><td align="left">3.86 m</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(12,3)</td><td align="left">9.46 s</td><td align="left">5.76 m</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(13,4)</td><td align="left">8.66 s</td><td align="left">5.77 m</td><td align="left">1.68 h</td><td align="left">NA</td></tr><tr><td align="left">(14,4)</td><td align="left">10.74 s</td><td align="left">7.73 m</td><td align="left">2.54 h</td><td align="left">NA</td></tr><tr><td align="left">(15,5)</td><td align="left">10.04 s</td><td align="left">7.65 m</td><td align="left">2.72 h</td><td align="left">NA</td></tr><tr><td align="left">(16,5)</td><td align="left">11.25 s</td><td align="left">9.25 m</td><td align="left">3.57 h</td><td align="left">NA</td></tr><tr><td align="left">(17,6)</td><td align="left">10.62 s</td><td align="left">9.19 m</td><td align="left">3.84 h</td><td align="left">47.27 h</td></tr><tr><td align="left">(18,6)</td><td align="left">12.38 s</td><td align="left">11.25 m</td><td align="left">4.96 h</td><td align="left">-</td></tr><tr><td align="left">(19,7)</td><td align="left">12.13 s</td><td align="left">11.54 m</td><td align="left">5.52 h</td><td align="left">-</td></tr></tbody></table></table-wrap>
<table-wrap id="Tab4"><label>Table 4</label><caption><p>Running time of LDDMS3</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">
<italic>d</italic>
<sub>2</sub>
</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th></tr></thead><tbody><tr><td align="left">(<italic>l,d</italic><sub>1</sub>)</td><td align="left"/><td align="left"/><td align="left"/><td align="left"/></tr><tr><td align="left">(7,1)</td><td align="left">5.59 s</td><td align="left">NA</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(8,1)</td><td align="left">6.66 s</td><td align="left">NA</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(9,2)</td><td align="left">8.78 s</td><td align="left">8.79 s</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(10,2)</td><td align="left">9.32 s</td><td align="left">9.17 s</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(11,3)</td><td align="left">12.09 s</td><td align="left">12.22 s</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(12,3)</td><td align="left">11.49 s</td><td align="left">11.97 s</td><td align="left">NA</td><td align="left">NA</td></tr><tr><td align="left">(13,4)</td><td align="left">16.09 s</td><td align="left">16.44 s</td><td align="left">25.55 s</td><td align="left">NA</td></tr><tr><td align="left">(14,4)</td><td align="left">14.41 s</td><td align="left">14.71 s</td><td align="left">19.68 s</td><td align="left">NA</td></tr><tr><td align="left">(15,5)</td><td align="left">20.71 s</td><td align="left">21.25 s</td><td align="left">35.73 s</td><td align="left">NA</td></tr><tr><td align="left">(16,5)</td><td align="left">18.35 s</td><td align="left">18.55 s</td><td align="left">28.36 s</td><td align="left">NA</td></tr><tr><td align="left">(17,6)</td><td align="left">25.86 s</td><td align="left">26.05 s</td><td align="left">53.12 s</td><td align="left">8.30 m</td></tr><tr><td align="left">(18,6)</td><td align="left">24.27 s</td><td align="left">23.23 s</td><td align="left">40.34 s</td><td align="left">6.44 m</td></tr><tr><td align="left">(19,7)</td><td align="left">32.01 s</td><td align="left">33.66 s</td><td align="left">1.08 m</td><td align="left">7.55 m</td></tr></tbody></table><table-wrap-foot><p>Time is in seconds (s), minutes (m) or hours (h). Cells with &#x02018;NA&#x02019; indicate instances that are not defined. Cells with &#x02018;-&#x02019; imply the algorithm did not complete in the stipulated 48 h</p></table-wrap-foot></table-wrap></p><p>It is obvious that as (<italic>l,d</italic><sub>1</sub>) instances become larger, all the LDDMS algorithms will take more time. However, an interesting observation is that for a fixed (<italic>l,d</italic><sub>1</sub>) instance, increasing the value of <italic>d</italic><sub>2</sub> will make LDDMS1 run faster but LDDMS2 and LDDMS3 slower. This is because of the way we generate the test cases. If <italic>d</italic><sub>2</sub> is very small, then the two <italic>l</italic>-mers we plant will be almost identical. In this case, we will find a lot of (<italic>l,d</italic><sub>1</sub>)-motifs in the end of Step 2 in LDDMS1. However, small values of <italic>d</italic><sub>2</sub> will make the neighborhood tree small, thus LDDMS2 and LDDMS3 will run faster.</p></sec></sec><sec id="Sec11"><title>Real datasets</title><p>We also used the datesets discussed in [<xref ref-type="bibr" rid="CR18">18</xref>] to test our algorithms. We chose a group of real datasets. We excluded datasets with only one input sequence because such datasets are not meaningful for our test.</p><p>We chose two relatively large number, 18 and 19 for the motif length. Then we re-computed <italic>d</italic><sub>1</sub> which will make (<italic>l,d</italic><sub>1</sub>) challanging instances since each dataset has different number of input sequences and different length for each sequence. However, as we noted before, the challenging instances will make the candidate size in LDDMS1 very small. In this case, we cannot manually plant a motif to avoid such a problem. Therefore, we will increment <italic>d</italic><sub>1</sub> by 2. We tested the minimum and maximum number of <italic>d</italic><sub>2</sub>, i.e., 0 and &#x0230a;<italic>d</italic><sub>2</sub>/2&#x0230b;. Table&#x000a0;<xref rid="Tab5" ref-type="table">5</xref> shows the datasets information and the (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>) instances we have tested.
<table-wrap id="Tab5"><label>Table 5</label><caption><p>Real datasets from [<xref ref-type="bibr" rid="CR18">18</xref>]</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Datasets</th><th align="left">
<italic>n</italic>
</th><th align="left">
<italic>m</italic>
</th><th align="left">
<italic>l</italic>
</th><th align="left">
<italic>d</italic>
</th><th align="left"><italic>d</italic><sub>1</sub>=<italic>d</italic>+2</th><th align="left">
<italic>d</italic>
<sub>2</sub>
</th></tr></thead><tbody><tr><td align="left">dm01r</td><td align="left">4</td><td align="left">1500</td><td align="left">18</td><td align="left">3</td><td align="left">5</td><td align="left">0, 2</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">19</td><td align="left">3</td><td align="left">5</td><td align="left">0, 2</td></tr><tr><td align="left">dm03r</td><td align="left">3</td><td align="left">2000</td><td align="left">18</td><td align="left">2</td><td align="left">4</td><td align="left">0, 2</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">19</td><td align="left">2</td><td align="left">4</td><td align="left">0, 2</td></tr><tr><td align="left">dm04r</td><td align="left">4</td><td align="left">2000</td><td align="left">18</td><td align="left">3</td><td align="left">5</td><td align="left">0, 2</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">19</td><td align="left">3</td><td align="left">5</td><td align="left">0, 2</td></tr><tr><td align="left">dm05r</td><td align="left">3</td><td align="left">2500</td><td align="left">18</td><td align="left">2</td><td align="left">4</td><td align="left">0, 2</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">19</td><td align="left">2</td><td align="left">4</td><td align="left">0, 2</td></tr></tbody></table></table-wrap></p><p>Table&#x000a0;<xref rid="Tab6" ref-type="table">6</xref> shows the running time of LDDMS1, LDDMS2 and LDDMS3 on real datasets. On the real dataset, for fixed (<italic>l,d</italic><sub>1</sub>), changing <italic>d</italic><sub>2</sub> does not affect the running time of LDDMS1 very much. This is because for a real dataset, the candidate size, i.e., the number of (<italic>l,d</italic><sub>1</sub>) motifs is unchanged. This is also true for the number of (<italic>l,d</italic><sub>2</sub>) motifs for LDDMS2. Moreover, as one can find, for a fixed <italic>d</italic><sub>1</sub>, increasing <italic>l</italic> will make LDDMS1 run faster because it will be less challenging. Generally, when <italic>d</italic><sub>2</sub> is large, LDDMS2 takes much more time. However, it is hard to say for LDDMS1 and LDDMS3, which one performs better. For example, on real dataset dm05r, when (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)=(18,4,2), LDDMS3 (4.07 s) overperforms LDDMS1 (10.79 s). However, on the same dataset, when (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>)=(19,4,2), LDDMS1 (2.31 s) overperforms LDDMS3 (4.55 s). The actual running time of these algorithms is highly dependent on the dataset and (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>) values.
<table-wrap id="Tab6"><label>Table 6</label><caption><p>Running time of LDDMS1, LDDMS2, LDDMS3 on real data</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Datasets</th><th align="left">
<italic>l</italic>
</th><th align="left">
<italic>d</italic>
<sub>1</sub>
</th><th align="left">
<italic>d</italic>
<sub>2</sub>
</th><th align="left">LDDMS1</th><th align="left">LDDMS2</th><th align="left">LDDMS3</th></tr></thead><tbody><tr><td align="left">dm01r</td><td align="left">18</td><td align="left">5</td><td align="left">0</td><td align="left">2.04 m</td><td align="left">4.15 s</td><td align="left">3.42 s</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">2</td><td align="left">2.03 m</td><td align="left">1.61 h</td><td align="left">6.67 s</td></tr><tr><td align="left"/><td align="left">19</td><td align="left">5</td><td align="left">0</td><td align="left">17.46 s</td><td align="left">4.43 s</td><td align="left">3.33 s</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">2</td><td align="left">17.35 s</td><td align="left">1.92 h</td><td align="left">5.40 s</td></tr><tr><td align="left">dm03r</td><td align="left">18</td><td align="left">4</td><td align="left">0</td><td align="left">14.80 s</td><td align="left">4.64 s</td><td align="left">2.73 s</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">2</td><td align="left">14.73 s</td><td align="left">1.78 h</td><td align="left">3.49 s</td></tr><tr><td align="left"/><td align="left">19</td><td align="left">4</td><td align="left">0</td><td align="left">3.30 s</td><td align="left">4.86 s</td><td align="left">2.83 s</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">2</td><td align="left">3.29 s</td><td align="left">2.07 h</td><td align="left">3.22 s</td></tr><tr><td align="left">dm04r</td><td align="left">18</td><td align="left">5</td><td align="left">0</td><td align="left">4.37 m</td><td align="left">7.16 s</td><td align="left">5.89 s</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">2</td><td align="left">4.37 m</td><td align="left">2.83 h</td><td align="left">11.17 s</td></tr><tr><td align="left"/><td align="left">19</td><td align="left">5</td><td align="left">0</td><td align="left">42.32 s</td><td align="left">7.74 s</td><td align="left">5.80 s</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">2</td><td align="left">42.48 s</td><td align="left">3.35 h</td><td align="left">9.03 s</td></tr><tr><td align="left">dm05r</td><td align="left">18</td><td align="left">4</td><td align="left">0</td><td align="left">10.70 s</td><td align="left">7.03 s</td><td align="left">4.07 s</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">2</td><td align="left">10.79 s</td><td align="left">2.68 h</td><td align="left">4.77 s</td></tr><tr><td align="left"/><td align="left">19</td><td align="left">4</td><td align="left">0</td><td align="left">2.32 s</td><td align="left">6.90 s</td><td align="left">4.21 s</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">2</td><td align="left">2.31 s</td><td align="left">3.15 h</td><td align="left">4.55 s</td></tr></tbody></table><table-wrap-foot><p>Time is in seconds (s), minutes (m) or hours (h)</p></table-wrap-foot></table-wrap></p></sec></sec><sec id="Sec12" sec-type="conclusion"><title>Conclusions</title><p>Efficient motif search algorithms are crucial in solving many bioinformatics problems effectively. In this paper, we have presented the (<italic>l,d</italic><sub>1</sub>,<italic>d</italic><sub>2</sub>) motif model, a more general model for the motif search problem. We also have proposed LDDMS1, LDDMS2 and LDDMS3, three exact efficient algorithms to solve the LDDMS problem. Theoretical analysis shows that our algorithms are very competitive. Experimental results also reveal that our algorithms perform well in practice.</p><p>In future we will focus on solving harder LDDMS instances, including those involving protein strings. We also plan to implement our algorithms in parallel.</p></sec></body><back><ack><title>Acknowledgements</title><p>Not applicable.</p><sec id="d29e5584"><title>Funding</title><p>This work has been supported in part by the NSF grants 1447711, 1743418 and 1843025. Publication costs have been funded by these grants as well.</p></sec><sec id="d29e5589" sec-type="data-availability"><title>Availability of data and materials</title><p>The real DNA sequence data can be downloaded from [<xref ref-type="bibr" rid="CR18">18</xref>]: <ext-link ext-link-type="uri" xlink:href="http://bio.cs.washington.edu/assessment/download.html">http://bio.cs.washington.edu/assessment/download.html</ext-link></p></sec><sec id="d29e5601"><title>About this supplement</title><p>This article has been published as part of <italic>BMC Genomics Volume 20 Supplement 5, 2019: Selected articles from the 7th IEEE International Conference on Computational Advances in Bio and Medical Sciences (ICCABS 2017): genomics</italic>. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="https://bmcgenomics.biomedcentral.com/articles/supplements/volume-20-supplement-5">https://bmcgenomics.biomedcentral.com/articles/supplements/volume-20-supplement-5</ext-link>.</p></sec></ack><notes notes-type="author-contribution"><title>Authors&#x02019; contributions</title><p>PX, MS and SR conceived the study. SR and PX designed the algorithms. PX implemented the algorithms and carried out the experiments. SR, PX, and MS analyzed the results and wrote the paper. All authors reviewed the manuscript.</p></notes><notes><title>Ethics approval and consent to participate</title><p>Not applicable.</p></notes><notes><title>Consent for publication</title><p>Not applicable.</p></notes><notes notes-type="COI-statement"><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></notes><notes><title>Publisher&#x02019;s Note</title><p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p></notes><ref-list id="Bib1"><title>References</title><ref id="CR1"><label>1</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pal</surname><given-names>S</given-names></name><name><surname>Xiao</surname><given-names>P</given-names></name><name><surname>Rajasekaran</surname><given-names>S</given-names></name></person-group><article-title>Efficient sequential and parallel algorithms for finding edit distance based motifs</article-title><source>BMC Genom</source><year>2016</year><volume>17</volume><issue>4</issue><fpage>465</fpage><pub-id pub-id-type="doi">10.1186/s12864-016-2789-9</pub-id></element-citation></ref><ref id="CR2"><label>2</label><mixed-citation publication-type="other">Xiao P, Rajasekaran S. Efficient exact algorithms for LDD motif search. In: 2017 IEEE 7th International Conference on Computational Advances in Bio and Medical Sciences (ICCABS). IEEE: 2017. p. 1&#x02013;1.</mixed-citation></ref><ref id="CR3"><label>3</label><mixed-citation publication-type="other">Xiao P, Pal S, Rajasekaran S. qPMS10: A randomized algorithm for efficiently solving quorum planted motif search problem. In: 2016 IEEE International Conference on Bioinformatics and Biomedicine (BIBM). IEEE: 2016. p. 670&#x02013;5.</mixed-citation></ref><ref id="CR4"><label>4</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xiao</surname><given-names>P</given-names></name><name><surname>Pal</surname><given-names>S</given-names></name><name><surname>Rajasekaran</surname><given-names>S</given-names></name></person-group><article-title>Randomised sequential and parallel algorithms for efficient quorum planted motif search</article-title><source>Int J Data Min Bioinforma</source><year>2017</year><volume>18</volume><issue>2</issue><fpage>105</fpage><lpage>24</lpage><pub-id pub-id-type="doi">10.1504/IJDMB.2017.086457</pub-id></element-citation></ref><ref id="CR5"><label>5</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yu</surname><given-names>Q</given-names></name><name><surname>Huo</surname><given-names>H</given-names></name><name><surname>Zhang</surname><given-names>Y</given-names></name><name><surname>Guo</surname><given-names>H</given-names></name></person-group><article-title>Pairmotif: a new pattern-driven algorithm for planted (l, d) DNA motif search</article-title><source>PLoS ONE</source><year>2012</year><volume>7</volume><issue>10</issue><fpage>48442</fpage><pub-id pub-id-type="doi">10.1371/journal.pone.0048442</pub-id></element-citation></ref><ref id="CR6"><label>6</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Blanchette</surname><given-names>M</given-names></name><name><surname>Schwikowski</surname><given-names>B</given-names></name><name><surname>Tompa</surname><given-names>M</given-names></name></person-group><article-title>Algorithms for phylogenetic footprinting</article-title><source>J Comput Biol</source><year>2002</year><volume>9</volume><issue>2</issue><fpage>211</fpage><lpage>23</lpage><pub-id pub-id-type="doi">10.1089/10665270252935421</pub-id><pub-id pub-id-type="pmid">12015878</pub-id></element-citation></ref><ref id="CR7"><label>7</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tanaka</surname><given-names>S</given-names></name></person-group><article-title>Improved exact enumerative algorithms for the planted (<italic>l,d</italic>)-motif search problem</article-title><source>IEEE/ACM Trans Comput Biol Bioinforma</source><year>2014</year><volume>11</volume><issue>2</issue><fpage>361</fpage><lpage>74</lpage><pub-id pub-id-type="doi">10.1109/TCBB.2014.2306842</pub-id></element-citation></ref><ref id="CR8"><label>8</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nicolae</surname><given-names>M</given-names></name><name><surname>Rajasekaran</surname><given-names>S</given-names></name></person-group><article-title>Efficient sequential and parallel algorithms for planted motif search</article-title><source>BMC Bioinforma</source><year>2014</year><volume>15</volume><issue>1</issue><fpage>1</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-15-34</pub-id></element-citation></ref><ref id="CR9"><label>9</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nicolae</surname><given-names>M</given-names></name><name><surname>Rajasekaran</surname><given-names>S</given-names></name></person-group><article-title>qPMS9: An efficient algorithm for quorum planted motif search</article-title><source>Sci Rep</source><year>2015</year><volume>5</volume><fpage>7813</fpage><pub-id pub-id-type="doi">10.1038/srep07813</pub-id><pub-id pub-id-type="pmid">25589474</pub-id></element-citation></ref><ref id="CR10"><label>10</label><mixed-citation publication-type="other">Pevzner PA, Sze S-H. Combinatorial approaches to finding subtle signals in DNA sequences. In: ISMB, vol. 8: 2000. p. 269&#x02013;78.</mixed-citation></ref><ref id="CR11"><label>11</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Karlin</surname><given-names>S</given-names></name><name><surname>Ost</surname><given-names>F</given-names></name><name><surname>Blaisdell</surname><given-names>BE</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Waterman</surname><given-names>MS</given-names></name></person-group><article-title>Patterns in DNA and Amino Acid Sequences and Their Statistical Significance</article-title><source>Mathematical Methods for DNA Sequences</source><year>1989</year><publisher-loc>Boca Raton</publisher-loc><publisher-name>CRC Press Inc</publisher-name></element-citation></ref><ref id="CR12"><label>12</label><mixed-citation publication-type="other">Rocke E, Tompa M. On finding novel gapped motifs in DNA sequences. In: In RECOMB98: Proceedings of the Second Annual International Conference on Computational Molecular Biology. ACM: 1998. p. 228&#x02013;33.</mixed-citation></ref><ref id="CR13"><label>13</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Sagot</surname><given-names>M-F</given-names></name></person-group><article-title>Spelling Approximate Repeated or Common Motifs using a Suffix Tree</article-title><source>LATIN&#x02019;98: Theoretical Informatics</source><year>1998</year><publisher-loc>Brazil</publisher-loc><publisher-name>Springer</publisher-name></element-citation></ref><ref id="CR14"><label>14</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pathak</surname><given-names>S</given-names></name><name><surname>Rajasekaran</surname><given-names>S</given-names></name><name><surname>Nicolae</surname><given-names>M</given-names></name></person-group><article-title>EMS1: An Elegant Algorithm for Edit Distance Based Motif Search</article-title><source>Int J Found Comput Sci</source><year>2013</year><volume>24</volume><issue>04</issue><fpage>473</fpage><lpage>86</lpage><pub-id pub-id-type="doi">10.1142/S0129054113500159</pub-id></element-citation></ref><ref id="CR15"><label>15</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>X</given-names></name><name><surname>Miao</surname><given-names>Y</given-names></name></person-group><article-title>GAEM: A Hybrid Algorithm Incorporating GA with EM for Planted Edited Motif Finding Problem</article-title><source>Curr Bioinforma</source><year>2014</year><volume>9</volume><issue>5</issue><fpage>463</fpage><lpage>9</lpage><pub-id pub-id-type="doi">10.2174/1574893609666140901222327</pub-id></element-citation></ref><ref id="CR16"><label>16</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Davila</surname><given-names>J</given-names></name><name><surname>Balla</surname><given-names>S</given-names></name><name><surname>Rajasekaran</surname><given-names>S</given-names></name></person-group><article-title>Fast and practical algorithms for planted (<italic>l,d</italic>) motif search</article-title><source>IEEE/ACM Trans Comput Biol Bioinforma</source><year>2007</year><volume>4</volume><issue>4</issue><fpage>544</fpage><lpage>52</lpage><pub-id pub-id-type="doi">10.1109/TCBB.2007.70241</pub-id></element-citation></ref><ref id="CR17"><label>17</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rajasekaran</surname><given-names>S</given-names></name><name><surname>Nicolae</surname><given-names>M</given-names></name></person-group><article-title>An elegant algorithm for the construction of suffix arrays</article-title><source>J Discret Algorithm</source><year>2014</year><volume>27</volume><fpage>21</fpage><lpage>8</lpage><pub-id pub-id-type="doi">10.1016/j.jda.2014.03.001</pub-id></element-citation></ref><ref id="CR18"><label>18</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tompa</surname><given-names>M</given-names></name><name><surname>Li</surname><given-names>N</given-names></name><name><surname>Bailey</surname><given-names>TL</given-names></name><name><surname>Church</surname><given-names>GM</given-names></name><name><surname>De Moor</surname><given-names>B</given-names></name><name><surname>Eskin</surname><given-names>E</given-names></name><name><surname>Favorov</surname><given-names>AV</given-names></name><name><surname>Frith</surname><given-names>MC</given-names></name><name><surname>Fu</surname><given-names>Y</given-names></name><name><surname>Kent</surname><given-names>WJ</given-names></name><etal/></person-group><article-title>Assessing computational tools for the discovery of transcription factor binding sites</article-title><source>Nat Biotechnol</source><year>2005</year><volume>23</volume><issue>1</issue><fpage>137</fpage><lpage>44</lpage><pub-id pub-id-type="doi">10.1038/nbt1053</pub-id><pub-id pub-id-type="pmid">15637633</pub-id></element-citation></ref></ref-list></back></article>